import java.util.*;public class S1helper{	// set global variables etc.	// some of these bio vars can be changed by a function, others are final	float[][] floatcities;	int NUMBER_OF_CITIES;	int SELECTION_SIZE = 1200;	int POPULATION_SIZE = 160; // make this no smaller than ELITE_SIZE+ELITE_MUTATIONS_SIZE+10	final int CROSSOVER_CHANCE = 85;	final int MUTATION_CHANCE = 15;	final int ELITE_SIZE = 5;	final int ELITE_MUTATIONS_SIZE = 35;	int TOURNAMENT_SIZE = 10;	float[][] firstPopulation;	float[][] population;	final int NUMBER_OF_GENERATIONS = 32000;	float[] FINAL_ROUTE;	float[][] parents; // parents created in tournament selection	boolean PRINT_FUNCTION = false; // enable or disable 'System.out.print' statements for diagnosis	    private static Random helper_random = new Random();		// THE route function!	// this takes care of combining alllll functions and returns ONE shortest route		public float[] calcRoute(float[][] input_floatcities) {			// all other functions depend on this initialization below, float[][] floatcities is needed 		// for distance calculations..		floatcities = input_floatcities;		NUMBER_OF_CITIES = floatcities.length - 1;		FINAL_ROUTE = new float[NUMBER_OF_CITIES];				// set float[][] vars		firstPopulation = new float[SELECTION_SIZE][NUMBER_OF_CITIES+1];		population = new float[POPULATION_SIZE][NUMBER_OF_CITIES+1];			// start evolution to determine shortest route		startEvolution();				// fetch shortest route, which is on top of the population[][]		FINAL_ROUTE = getFinalRoute();					return FINAL_ROUTE; // returns final route as a float[] array	}		private void startEvolution() {		System.out.println("\n------------------ Start of evolution ------------------");		System.out.println("The first generation will consist of "+SELECTION_SIZE+" chromosomes, next generations will consist of "+POPULATION_SIZE+" chromosomes. "+ELITE_SIZE+" elite chromosome(s) are transferred to each new generation, and "+ELITE_MUTATIONS_SIZE+" elite mutations are created to replace the worst chromosomes. Culculations will be done over "+NUMBER_OF_GENERATIONS+" generations.");		generateFirstGeneration();		firstPopulation = setDistances(firstPopulation);		firstPopulation = sort(firstPopulation);				//copy the best POPULATION_SIZE to the population table		for(int r=0;r<POPULATION_SIZE;r++) {			for(int c=0;c<NUMBER_OF_CITIES;c++) {				population[r][c] = firstPopulation[r][c];			}		}				// first generation is there, start with multiple new generations here		for(int g=0;g<NUMBER_OF_GENERATIONS;g++) {			fillPopulationWithRandomness();			createEliteMutations(); // replaces worst 5 routes by mutations of the best route (the one on top)			population = setDistances(population);			population = sort(population);		}				System.out.println("-------------------- End of evolution ------------------\n");	}		private float[] getFinalRoute() {		float[] array = new float[NUMBER_OF_CITIES];		for(int i=0;i<NUMBER_OF_CITIES;i++) {			array[i] = population[0][i];		}		return array;	}			// distance calculations			// calculate the euclidian distances for all		// routes in the float[][] firstPopulation array		// the distance is written to the last column of that array		private float[][] setDistances(float[][] array_to_set) {		// variable to store distance				//for grid distance calc		//float d = 0;		float d = 0;				// to remember what point was used last (needed for calculation below)		// we'll use previous[]; previous[0] holds the x-coord, previous[1] holds the y-coord		// using integers makes sure we do not need to use (PointP) objects in the array, 		// saving (my) precioussss memory		float[] previous = new float[2];		previous[0] = 0;		previous[1] = 0;				for(int r=0;r<array_to_set.length;r++) {			// cycle through all points and add their distance to the last column of the array, 			// which looks like this (NUMBER_OF_CITIES is 5 here):			/*			   (i..................->)				0	1	2	3	4	5		(r)	0	1	5	3	2	4	-			1	"	"	"	"	"	"			2			the dash (-) must be replaced with the distance of that route (route 15324 in this case)			the numbers represent the index of the point in the floatcities array, 1 stands for floatcities[1] for example			*/								for (int i=0; i<NUMBER_OF_CITIES; i++) {				d += calcDirectEuclidianDistance(previous[0], previous[1], floatcities[(int)array_to_set[r][i]][0], floatcities[(int)array_to_set[r][i]][1]);				previous[0] = (float)floatcities[(int)array_to_set[r][i]][0]; //x				previous[1] = (float)floatcities[(int)array_to_set[r][i]][1]; //y			}								// now add the distance to get back to start, so we do have a complete route			d += calcDirectEuclidianDistance(previous[0], previous[1], (float)0.0, (float)0.0);						//System.out.print(d+" = dah distance calced in setDistances()\n");			// write the distance for this route to the array			array_to_set[r][NUMBER_OF_CITIES]=d;			// reset for next route/row			previous[0] = 0;			previous[1] = 0;			d = (float) 0.0;					}		//if (PRINT_FUNCTION) System.out.println("+ Distances were set.");		return array_to_set;	}		// calculate grid distance between x,y and x,y		private float calcDirectGridDistance (float px, float py, float qx, float qy) {		float griddistance = 0;		float xdistance = (float) Math.abs(px - qx);		float ydistance = (float) Math.abs(py - qy);		griddistance = xdistance + ydistance;		return griddistance;	}		// calculate euclidian distance between x,y and x,y		private float calcDirectEuclidianDistance(float px, float py, float qx, float qy) {		float tmp = (float) Math.sqrt((qx-px)*(qx-px) + (qy-py)*(qy-py));		return (float) 100*tmp;	}		// random permutation generation	// returns-or-creates? an array with random routes 		private void generateFirstGeneration() {		// this uses some global vars defined at the top of S1helper		float[] array = new float[NUMBER_OF_CITIES+1];								// fill the array with 1...NUMBER_OF_CITIES                        		for (int x=0;x<NUMBER_OF_CITIES;x++) {			array[x] = (float)x+1;		}				// fill this generation with randomness     		for (int r=0;r<SELECTION_SIZE;r++) {			//System.out.print("genRG r= "+r+"\n");			// execute random swap function			array = randomSwap(array);           			for (int c=0;c<NUMBER_OF_CITIES;c++) {				//System.out.print("genRG c= "+c+"\narray[c]= "+array[c]+"\n");				 				 firstPopulation[r][c] = array[c];			}						//System.out.println("");		}		if (PRINT_FUNCTION) System.out.println("+ The first generation was generated successfully.");	}	private void fillPopulationWithRandomness() {		// this function fills population[][],		// saving the first ELITE_SIZE on top		// overwriting everything else with random routes/chromosomes!		float[] array = new float[NUMBER_OF_CITIES+1];								// fill the array with 1...NUMBER_OF_CITIES                        		for (int x=0;x<NUMBER_OF_CITIES;x++) {			array[x] = (float)x+1;		}				// fill this generation with randomness     		for (int r=ELITE_SIZE;r<POPULATION_SIZE;r++) {			//System.out.print("genRG r= "+r+"\n");			// execute random swap function			array = randomSwap(array);           			for (int c=0;c<NUMBER_OF_CITIES;c++) {				//System.out.print("genRG c= "+c+"\narray[c]= "+array[c]+"\n");				population[r][c] = array[c];			}						//System.out.println("");		}		//if (PRINT_FUNCTION) System.out.println("+ The population was filled with new random routes, saving the elite.");	}		private float[] generateRandomChromosome() {		float[] randomChromosome = new float[NUMBER_OF_CITIES];		// vult de array met de getallen "1" t/m "NUMBER_OF_CITIES"                      		for (int x = 0; x<NUMBER_OF_CITIES; x++) {			randomChromosome[x] = (float)x+1;		}		randomChromosome = randomSwap(randomChromosome);		randomChromosome = randomSwap(randomChromosome);     		randomChromosome = randomSwap(randomChromosome);     		return(randomChromosome);	}	// selection mechanism for new generation	// tournament selection function		private void tournamentSelection() {			// we'll use 2 parents for chromosome children, if not this algorithm isn't that biological..		int PARENTS_SIZE = 2;		float[][] parents = new float[PARENTS_SIZE][NUMBER_OF_CITIES+1];				// define the contestants; the number of contestants = TOURNAMENT_SIZE		float[][] contestants = new float[TOURNAMENT_SIZE][NUMBER_OF_CITIES+1];				// select a random spot within the population		int tour_start = getRandomInt(0,POPULATION_SIZE-TOURNAMENT_SIZE);		int tour_stop = tour_start + TOURNAMENT_SIZE;				if (PRINT_FUNCTION) System.out.print(tour_start+" (>= start of tournament (array index value!), minimum=0)\n");		if (PRINT_FUNCTION) System.out.print(tour_stop+" (< stop of tournament)\n\n");		// adding this group to the contestants array		int contestant_row_count = 0;				for(int i=tour_start;i<tour_stop;i++) {			for (int r=0;r<NUMBER_OF_CITIES;r++) {				contestants[contestant_row_count][r] = firstPopulation[i][r];				if (PRINT_FUNCTION) System.out.print(contestants[contestant_row_count][r]+"   ");			}			contestant_row_count++;			if (PRINT_FUNCTION) System.out.print(" (= contestantrow)\n");		}				// now select the best two as parents and return them				// set distances..		contestants = setDistances(contestants);				// sort the array contestants (shortest route on **top**)		contestants = sort(contestants);				// add/copy the best PARENT_SIZE (2 parents probably) to parents		// these are on top of the contestants array, because that one was sorted up here		for(int i=0;i<PARENTS_SIZE;i++) {			for (int t=0;t<=NUMBER_OF_CITIES;t++) { // also copy the distance				parents[i][t] = contestants[i][t];				//System.out.print(parents[i][t]+"   ");			}			//System.out.print(" (= a parent with the last number being its distance)\n");		}				// mutate parents		//parents = mutateChromosomes(parents);				//print 		for(int i=0;i<PARENTS_SIZE;i++) {			for (int t=0;t<=NUMBER_OF_CITIES;t++) { 				if (PRINT_FUNCTION) System.out.print(parents[i][t]+"   ");			}			if (PRINT_FUNCTION) System.out.print(" (= a parent with the last number being its distance)\n");		}	}		public void createEliteMutations() {		float[] array = new float[NUMBER_OF_CITIES+1]; // swap function requires an extra column that is not swapped		float[] temp = new float[NUMBER_OF_CITIES+1];		// fill the array with elite genes		                  		for (int c=0;c<NUMBER_OF_CITIES;c++) {			array[c] = population[0][c];		}				for (int r=POPULATION_SIZE-1;r>=POPULATION_SIZE-ELITE_MUTATIONS_SIZE;r--) {			temp = randomSwap(array);			for (int c=0;c<NUMBER_OF_CITIES;c++) {				population[r][c] = temp[c];			}		}		// print functions		/*		System.out.print("The elite:\n");		for (int r=0;r<ELITE_SIZE;r++) {			for (int c=0;c<NUMBER_OF_CITIES;c++) {				System.out.print(population[r][c]+"  ");			}			System.out.print("\n");		}		System.out.print("The elite mutations:\n");		for (int r=POPULATION_SIZE-1;r>=POPULATION_SIZE-ELITE_MUTATIONS_SIZE;r--) {			for (int c=0;c<NUMBER_OF_CITIES;c++) {				System.out.print(population[r][c]+"  ");			}			System.out.print("\n");		}		*/		//if (PRINT_FUNCTION) System.out.print("+ The worst chromosomes were replaced by elite mutations.\n");	}		// crossover function	// combines genes of 2 parents to create one for two children			// mutation function		private float[] mutateChromosome(float[] array) {		if (getRandomInt(0,100) <= MUTATION_CHANCE) { // mutate only if randomint equals/is below MUTATION_CHANCE			// mutate			randomSwap(array);			if (PRINT_FUNCTION) System.out.println("mutateChromosome(): mutated!\n");		}		else {			if (PRINT_FUNCTION) System.out.println("mutateChromosome(): NOT mutated!\n");		}		return array;	}	private float[][] mutateChromosomes(float[][] array) {		for (int z=0;z<array.length;z++) {			if (getRandomInt(0,100) <= MUTATION_CHANCE) { // mutate only if randomint equals/is below MUTATION_CHANCE				// mutate				randomSwap(array[z]);				if (PRINT_FUNCTION) System.out.println("mutateChromosome(): mutated!");			}			else {				if (PRINT_FUNCTION) System.out.println("mutateChromosome(): NOT mutated!");			}		}		return array;	}	// insertion of new generation	// ..	// "utilities" here		// swap function, swaps 2 values in an array	// please supply: 1. the array that needs swapping, 2. the places to be swapped	private float[] swap(float[] this_array, int swap1, int swap2) {			float temp = this_array[swap1];			this_array[swap1] = this_array[swap2];			this_array[swap2] = temp; 			return this_array;	}	// RANDOM swap function, swaps 2 random values in an array	// feed an array	private float[] randomSwap(float[] this_array) {			// determine which spots are swapped						/* diagnostic print function, prints the numbers in the array to be swapped			for (int z=0;z<this_array.length;z++) {				System.out.print("arraytest "+this_array[z]+" ");			}			System.out.println("\n");			*/						// NOTE: this REALLY expects the last column not to be swapped! generally herein can be found the distance						int swap1 = getRandomInt(0,this_array.length-2);			int swap2 = getRandomInt(0,this_array.length-2);			while (swap2 == swap1) {				swap2 = getRandomInt(0,this_array.length-2);			}			float temp = this_array[swap1];			this_array[swap1] = this_array[swap2];			this_array[swap2] = temp; 			return this_array;	}		public float[][] sort(float[][] array) {   		for (int t = 0; t<array.length; t++) {			for(int v = 0; v<array[t].length; v++) {				//System.out.print(array[t][v]);				//System.out.print("  ");			}			//System.out.println("");		}				//System.out.println("");  		        for(int i = array.length-1; i>0; i--) {						float currentMax = array[0][array[i].length-1];			float hulpFloat;			int currentMaxIndex = 0;           			for(int j = 1; j<=i; j++) {				if(currentMax < array[j][array[j].length-1]) {					currentMax = array[j][array[j].length-1];					currentMaxIndex = j;				}			}                			if (currentMaxIndex!=i) {				array[currentMaxIndex][array[i].length-1] = array[i][array[i].length-1];                array[i][array[i].length-1] = currentMax;                                                for(int r = array[i].length - 2 ; r>=0; r--) {					hulpFloat = array[currentMaxIndex][r];        					array[currentMaxIndex][r] = array[i][r];					array[i][r] = hulpFloat;                }             			}		}    		/*		//print		for (int t = 0; t<array.length; t++) {			for(int v = 0; v<array[t].length; v++) {				System.out.print(array[t][v]);				System.out.print("  ");			}			System.out.println("");		}*/	if (PRINT_FUNCTION) System.out.println("+ An array was sorted.");	return array;		}		// give a random int between int_one and int_two	// also int_one and int_two are possible outputs!    private static int getRandomInt(int int_low, int int_high) {                return (int) Math.floor(helper_random.nextDouble() * (int_high - int_low + 1)) + int_low;    }}