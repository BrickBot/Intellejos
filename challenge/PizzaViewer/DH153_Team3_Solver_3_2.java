/*



€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
        ‹‹≤≤ﬂﬂﬂﬂ≤‹                  ‹‹‹‹‹
       €€≤›       ﬂ€‹‹           ‹€€€€€ﬂﬂﬂ≤‹‹                 ‹‹‹‹‹‹‹‹
        ﬂﬂ€‹‹       ﬂ€€€‹‹‹   ‹ €€€€ﬂ       ﬂ≤‹      ‹‹‹‹≤≤≤€ﬂﬂﬂ€€€€€€€€≤‹
         ‹‹˛ﬂﬂﬂ       ﬂ€€€€≤≤ﬂ  ﬂ€€›         ﬁ›ﬂ≤€€€€€€ﬂﬂﬂ‹‹‹€ﬂﬂﬂ      ﬂ€≤≤‹
 ‹≤≤≤≤‹ €€›       ‹‹€€‹‹ﬂ€€€›     ﬂ≤‹       ‹ﬂ   ﬂﬂ€‹‹‹ﬂﬂ≤ﬂﬂ ‹‹‹        ﬁ€€€€‹
ﬁ›  ﬂﬂ≤≤‹€€   ‹‹€€€€€€ ﬂ€≤€€€‹‹      ﬂﬂﬂ ﬂﬂ   ‹‹‹€€€€€€ﬂ  ‹‹€€€€€€‹‹   ‹€€€€€€
 ﬂ˛‹   ﬂﬂ ‹‹€‹ﬁ€€€€€€€›    ﬂﬂﬂ≤€€€€‹‹‹‹‹‹€€€≤≤€€€€€€€€  ‹€€€€€€ﬂﬂ€€€ﬂ‹€€€€ﬂﬂ€‹≤
      ‹‹≤≤≤ﬂﬂ€€€≤≤€€€€€€‹‹        ﬂﬂ≤€€€ﬂﬂﬂ  €€€€€€€€ﬂ‹€€€€€€ﬂ   ﬁ€≤€≤ﬂﬂ‹‹€€€€ﬂ
   ‹≤≤≤ﬂﬂ‹‹≤≤€€€› ﬂﬂ≤≤€€€€€€‹  ‹‹€€€€€‹     ﬁ€€€€€€€›ﬁ€€€€€€     ﬁ≤€‹‹€€ﬂﬂﬂ
 ‹€€€€    €€€€€€€    ﬂ≤€€€€€€€‹ﬁ€€€€€€≤      €€€€€€€ €€€€€€›   ‹≤€ﬂﬂﬂ ‹‹‹‹
≤€€€€›    ﬁ€€€€€€›    ﬁ€€€€€€€≤›€€€€€€€‹     ﬁ€€€€€€ ﬁ€€€€€€‹    ‹‹≤≤€€€€€€€‹
€€€€€›    ﬁ€€€€€€›    ﬁ€€€€€€€ﬂﬁ≤€€€€€€€‹     €€€€€€› ﬂ€€€€€€€€€€ﬂﬂﬂﬂ€€€€€€€€≤
ﬂ€€€€≤‹   ﬁ€€€€€€≤   ‹€€€€€€ﬂ  ﬁ≤€€€€∞€€€€‹   ﬁ€€€€€€    ﬂﬂﬂﬂ   ‹‹     ﬂ€€€€€€≤
  ﬂ€€€≤≤‹‹€€€€€€€€‹‹€≤≤≤ﬂﬂ     ≤≤€€€€› ﬂ€≤≤€‹  ≤€€€€€›      ‹‹€€ﬂ       ﬁ€€€€€€
      ﬂﬂﬂ€€€€€€€€€≤≤‹‹‹       ‹€≤€€€€›   ﬂ€€€€‹ﬁ€€€€€€ ‹‹‹€€€ﬂ          ﬁ€€€€€€
        ﬁ€€€€€€€€ﬂ€€€€€€€≤‹‹‹   ﬂﬂﬂ€€       ﬂﬂ€€≤€€€€€›€€€€€›           €€€€€€
     ‹‹‹€€€€€€€ﬂ   ﬂﬂﬂ€€€€€€€€€€€€‹‹‹‹‹‹        ﬂﬂ€≤€€€‹ﬂ€€€€‹        ‹€€€€≤≤
   ‹€€ﬂﬂ    ﬂﬂﬂ≤≤≤‹‹      ﬂﬂﬂﬂ€€€€€€€€€€€€€€€€‹‹‹    ﬂﬂﬂ≤‹‹ﬂﬂ€≤≤‹‹‹€€€€≤€€≤≤
  ≤€€›             ﬂ≤‹            ﬂﬂﬂ€€€€€€€€€€€€€‹ ‹‹‹‹‹‹‹€€€€€€€‹±≤€€€ﬂﬂﬂ
   ﬂ≤≤‹             ﬁ€€‹  ‹‹€€≤ﬂ ˛‹‹   ﬂ€€€€€€€€€€€€€≤ﬂﬂ    ﬂﬂﬂﬂ€€€€€€€€€€‹‹
     ﬂ€€≤‹‹        ‹€€€€›€≤€€€›    ﬂ≤≤‹ ﬁ€€€€€€€€ﬂﬂ  ±       ‹‹˛   ﬂﬂ€€€€€€€›
    ‹≤≤≤€€€€€€€€€€€€€€€ﬂ ﬂ€€€€€‹‹   ﬁ€€€€€€≤≤ﬂﬂ      ∞ ‹‹‹‹≤≤≤›      ﬁ€€€€€ﬂ
   ﬂ ‹≤ﬂﬂﬂ‹≤ﬂ€€≤ﬂﬂﬂﬂﬂ       ﬂﬂﬂﬂ€€€€‹‹‹‹‹‹‹‹‹‹‹‹‹‹€€€€ﬂﬂﬂ   ﬂﬂ≤‹    ‹≤≤≤ﬂﬂ
  ‹€€ﬂ     ≤€€€€‹                  ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ   ‹‹‹‹‹‹‹    ﬂﬂ‹‹‹
 €€€›      ﬁ€€›ﬂ≤€‹              ‹≤≤≤≤ﬂ         ‹‹≤≤€ﬂﬂﬂ≤ﬂﬂ€€€€‹‹  ﬂﬂ€€€‹‹
  ﬂﬂ€€€ﬂ€€€€€€ﬂ ﬂ‹‹                                            ‹‹ﬂ ﬂ€€€€€‹
       ﬁ€€€€€    ﬁ€≤    Nacor & Pieter Weterings Present:     ≤€›    €€€€€›
       €€€€€›    €€€›                                        ﬁ€€€    ﬁ€€€€€
       ﬂ€€€€€‹  ≤€€≤      "DH153 - Team 3 - Solver v 3.2"      ≤€€≤  ‹€€€€€ﬂ
         ﬂﬂ€€€€€€€ﬂ                                            ﬂ€€€€€€€ﬂﬂ
          ‹€€€€€ﬂ         									   	ﬂ€€€€€‹
        ‹€€€€€ﬂ ﬂ‹‹           									‹‹ﬂ ﬂ€€€€€‹
       ﬁ€€€€€    ﬁ€≤                                ≤			€›    €€€€€›
       €€€€€›    €€€›                                        ﬁ€€€    ﬁ€€€€€
       ﬂ€€€€€‹ ‹≤€€≤   ‹€€€≤≤‹‹                    ‹‹≤≤€€€‹   ≤€€≤‹ ‹€€€€€ﬂ
         ﬂﬂ€€€€€€€ﬂ ‹‹€€ﬂ    ﬂ€€‹                ‹€€ﬂ    ﬂ€€‹‹ ﬂ€€€€€€€ﬂﬂ
           ‹€€€ﬂ€‹€€ﬂﬂ       ‹€€ﬂ‹‹‹‹‹      ‹‹‹‹‹ﬂ€€‹       ﬂﬂ€€‹€ﬂ€€€‹
        ‹€€€€€€€€ﬂﬂ≤≤≤‹‹‹€€€€€≤€€ﬂﬂﬂﬂ€€‹ ‹‹€€ﬂﬂﬂﬂ€€≤€€€€€‹‹‹≤≤≤ﬂﬂ€€€€€€€€‹
      ‹€€€€€ﬂ‹€€›      ﬂﬂﬂﬂﬂ€€€‹      ﬂ€€€€ﬂ      ‹€€€ﬂﬂﬂﬂﬂ      ﬁ€€‹ﬂ€€€€€‹
     ‹€€€€€›ﬁ€€€€‹      ‹‹‹€€€ﬂﬂ€€‹‹‹€€€ﬂ€€€€‹‹‹€€ﬂﬂ€€€‹‹‹      ‹€€€€›ﬁ€€€€€‹
     €€€€€€› ﬂ€€€€€‹‹‹€€€€€ﬂ      €€€ﬂﬂ    ﬂﬂ€€€      ﬂ€€€€€‹‹‹€€€€€ﬂ ﬁ€€€€€€
      ﬂﬂ€€€€‹‹ ﬂﬂ€€€€€€€ﬂﬂ    ‹‹€ﬂﬂ            ﬂﬂ€‹‹    ﬂﬂ€€€€€€€ﬂﬂ ‹‹€€€€ﬂﬂ
           ﬂﬂ€€€‹‹‹     ‹‹‹€≤ﬂﬂ                    ﬂﬂ≤€‹‹‹     ‹‹‹€€€ﬂﬂ
               €€€›       ﬁ€›     ‹‹€ﬂ   €   ﬂ€‹‹     ﬁ€›       ﬁ€€€
                ﬂ€€‹     ‹€ﬂ ‹‹‹€€ﬂﬂ    €€€    ﬂﬂ€€‹‹‹ ﬂ€‹     ‹€€ﬂ
                  ﬂﬂ€€‹€€€€€€ﬂﬂﬂ       ≤€€€€       ﬂﬂﬂ€€€€€€‹€€ﬂﬂ
                      ﬂﬂﬂﬂ            ﬁ€€€€€€            ﬂﬂﬂﬂ
                                      €€€€€€€€
                                     €€€€€‹€€€›
                                    ﬁ€€€€€›ﬁ€€€
                                    €€€€€€‹€€€€›
                                    €€€€€›ﬁ€€€€€
                                    €€€€€›≤€€€€€
           ﬂ€≤ﬂ‹‹‹‹‹                €€€€€∞€€€€€€
             ﬂ≤≤€€€€€€€€‹‹          ﬁ≤€€€∞€€€€€€               ‹‹‹‹‹ﬂ≤€ﬂ
               ﬂ€€€€€€€ﬂﬂ€€€‹‹       ≤€€€€€€€€€€         ‹‹€€€€€€€€≤≤ﬂ
                 ﬂ€€€€€€€€‹€ﬂﬂ€€‹‹   ﬂ€€€›ﬁ€€€≤›     ‹‹€€€ﬂﬂ€€€€€€€ﬂ
                   ﬂ€€€€€€€€€€€ﬂ€€€‹  ≤€€›ﬁ€€≤≤  ‹‹€€ﬂﬂ€‹€€€€€€€€ﬂ
                     ﬂ€€€€€€€€€€‹‹ﬂﬂ€‹ ≤€€ €≤≤› €€€ﬂ€€€€€€€€€€€ﬂ
                        ﬂ€€€€€€€€€€€ﬂ€€ ≤≤ ≤≤‹€€ﬂ‹‹€€€€€€€€€€ﬂ
                          ﬂﬂ€€€€€€€€€‹€›ﬁ≤€≤›€≤≤€€€€€€€€€€ﬂ
                ‹‹‹‹‹‹‹‹‹‹‹‹   ﬂﬂ€€€€€‹ €€≤≤€‹€€€€€€€€€ﬂﬂ
         ‹‹‹‹€€€€€€€€€€€€€€€€€€€‹‹‹≤≤ﬂ≤‹€€€€‹€€€€€ﬂﬂ   ‹‹‹‹‹‹‹‹‹‹‹‹
 ‹‹‹‹€€€€€€€€€€ﬂﬂ‹‹‹‹ﬂﬂﬂﬂﬂﬂﬂ≤≤≤€€€€€€€€€≤≤≤‹≤ﬂ≤≤‹‹‹€€€€€€€€€€€€€€€€€€€‹‹‹‹
  ﬂ€€€≤≤≤€€€€€€€€≤≤≤€€€€€€€€‹‹‹‹‹‹‹‹ﬂ€ﬂ€‹‹€€ﬂ€ﬂ≤≤≤ﬂﬂﬂﬂﬂﬂﬂﬂ‹‹‹‹‹‹‹‹ﬂﬂﬂ€ﬂ€€€€€€‹‹
      ﬂﬂﬂ≤≤≤€€€€€€€≤≤≤≤€€€€€€€ﬂﬂﬂ ‹‹ﬂ‹€€€€€€‹ﬂ€‹‹ ﬂﬂﬂ€€€€€€€€€€€€€€€€€€€€ﬂﬂﬂ
             ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ       ‹‹€€ﬂ€€€ﬂﬂ€€€ﬂ€‹ﬂ€€€€‹‹       ﬂﬂﬂﬂﬂﬂﬂﬂ
                            ‹€€€€€€€€   €€€  €€‹ﬂ€€€€€‹
                           ‹€€€€€€€ﬂ    €€›   ﬂ€€€€€€€€‹
                           €€€€ﬂﬂﬂ     ﬁ€€›      ﬂﬂﬂ€€€€
                                       ﬁ€€€
                                        €€≤
                                        ﬁ€≤›
                                         ﬂ≤€‹
                                            ﬂﬂ
€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€


 */
 
// Imports
//----------------------------------------------------------------------------
 
		import javax.swing.*;
		import java.awt.*;
		import java.awt.event.*;





public class DH153_Team3_Solver_3_2 implements Solver 
	{
  
  
public boolean Answer = false;
  		


public int [] LocationsXDone = new int [100];
public int [] LocationsYDone = new int [100];
public int Target_Amount = 0;
  

     
    public static void main(String[] args) 
    	{
        DH153_Team3_Solver_3_2 broodjeBanaan = new DH153_Team3_Solver_3_2();
        
  
        
// PizzaViewer        
        new PizzaViewer(broodjeBanaan);

    	}



//----------------------------------------------------------------------------       	    
// Creates a new instance of DH153_Team3_Solver_3_# 
//----------------------------------------------------------------------------
    public DH153_Team3_Solver_3_2()  
    	{
    		
    	}

	public boolean AreWeThereYet()
		{
		return Answer;	
		}

	


//-----------------------------------------------------------------------------    
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Main Solver Function
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++    

  	public PointP[] computeRoute(PointP[] cities) 
    	{  
	
		BananaClass bananaclass = new BananaClass();
		bananaclass.target_amount = (cities.length-1);	
		bananaclass.GridSizeX = PizzaPanel.COLS;
		bananaclass.GridSizeY = PizzaPanel.ROWS;
		Target_Amount = cities.length;	
    	PointP[] route = new PointP[cities.length];
       

// Preparation of variables				
 			for (int i=1; i<(route.length); i++) 
        		{   
        		bananaclass.InitiateLocVars( i, cities[i].x, cities[i].y);	
        		}  



				
// Calculation Function				
				bananaclass.AlgorithmS1();


       	 		route[0] = new PointP(cities[0]);   // starting point should not change
        
        			for (int i=1; i<route.length; i++) 
        			{
            		route[i] =  new PointP(cities[bananaclass.FinalArray[i]]);
            		LocationsXDone[i-1] = bananaclass.LocationsX[bananaclass.FinalArray[i]];
            		LocationsYDone[i-1] = bananaclass.LocationsY[bananaclass.FinalArray[i]];
       		 		}
	
       			Answer = true;
        		return route;
    			}
    	
    	

    
    			public String getAuthors() 
    				{
        			return "Pieter Weterings & Nacor Martina";
   					 }
    
   
    			public String getDescription() 
    				{
        			return "Solves all yer Problems....";
    				}

    
}

 
 
 
 
 
 





 class BananaClass 
 	{
 	
//############################################################################
//						Declaration of Variables
//############################################################################


//----------------------------------------------------------------------------
// Public Variables
//----------------------------------------------------------------------------
	public int target_amount;
	public int RecurCounter = 0;  

//----------------------------------------------------------------------------
// Size Definitions for the Grid 
//----------------------------------------------------------------------------
	public int GridSizeX; // PizzaPanel.COLS
	public int GridSizeY; // PizzaPanel.ROWS


//----------------------------------------------------------------------------
// Public Array's & Vars Defined from other classes
//----------------------------------------------------------------------------
	
	public int [] LocationsX   	= 		new int[100];
	public int [] LocationsY   	= 		new int[100];	
	public int [] NotMultiDist 	= 		new int[100]; // Has the locations not added to the MultiDist array		
	public int [] FinalArray	= 		new int[100]; // serves as index for the MultiDist Array and as the export Array of the final points		
	public int [] MultiDist    	= 		new int[100]; // Has the pointer locations for graph 
	
	String[] ThaBigOne         	= 		new String [2000];    // holds all the data on the distance from lines to points


// amount of targets to be implemented
	void InitiateLocVars(int i,int Xloc,int Yloc)
 			{
 			LocationsX[i] = Xloc; 
 			LocationsY[i] = Yloc;		
 			}		 


//----------------------------------------------------------------------------
// Constructor
//----------------------------------------------------------------------------

	BananaClass() 
	{
 	}


	
//----------------------------------------------------------------------------
//############################################################################
//								Code				
//############################################################################
//----------------------------------------------------------------------------
  
void AlgorithmS1()
{



//----------------------------------------------------------------------------
// Local Varibles & Arrays
//----------------------------------------------------------------------------

int CountKeeper		= 0; 

int CornerXminYmax 	= 0;
int CornerXmaxYmax 	= 0;
int CornerXmaxYmin 	= 0;
int CornerXminYmin 	= 0;


int	[] CurrZeroDist 	= new int[target_amount+5];
int [] RecurPointer 	= new int[target_amount+5]; 
int [] youBetterThenMe 	= new int[target_amount+5];

		
		
		for (int o = 1; o<=(target_amount);o++)
			{

// calculation for CornerXminYmin
//----------------------------------------------------------------------------
				if((LocationsX[o] != 0)||(LocationsY[o] != 0))
					{
					
				if( ((LocationsX[o]+ LocationsY[o] ) < (LocationsX[CornerXminYmin]+ LocationsY[CornerXminYmin])) || (CornerXminYmin == 0)   )
							{
								CornerXminYmin = o;
							}
					
					else if((LocationsX[o]+ LocationsY[o]) == (LocationsX[CornerXminYmin]+ LocationsY[CornerXminYmin]))
							{
						
								if(LocationsY[o] < LocationsY[CornerXminYmin])
									{
								CornerXminYmin = o;	
									}
							
							}
					}


// calculation for CornerXmaxYmax
//----------------------------------------------------------------------------				
					if( ((LocationsX[o]+ LocationsY[o] ) > (LocationsX[CornerXmaxYmax]+ LocationsY[CornerXmaxYmax])) || (CornerXmaxYmax == 0)   )
							{
							CornerXmaxYmax = o;
							}
					
					else if((LocationsX[o]+ LocationsY[o]) == (LocationsX[CornerXmaxYmax]+ LocationsY[CornerXmaxYmax]))
							{
						
								if(LocationsX[o] > LocationsX[CornerXmaxYmax])
									{
										
									CornerXmaxYmax = o;	
									}
							
							}
				
				
// calculation for CornerXmaxYmin
//----------------------------------------------------------------------------				
				
				if(  (((Math.abs(GridSizeX-LocationsX[o])) + LocationsY[o]) < ((Math.abs(GridSizeX-LocationsX[CornerXmaxYmin])) + LocationsY[CornerXmaxYmin]))||(CornerXmaxYmin == 0))
						{
							CornerXmaxYmin = o;		
						}
					
			else if(((Math.abs(GridSizeX-LocationsX[o])) + LocationsY[o]) == ((Math.abs(GridSizeX-LocationsX[CornerXmaxYmin])) + LocationsY[CornerXmaxYmin]))
							{
						
								if(LocationsX[o] > LocationsX[CornerXmaxYmin])
									{
										
									CornerXmaxYmax = o;	
									}
							
							}
				

// calculation for CornerXminYmax
//----------------------------------------------------------------------------

					if(  (((Math.abs(GridSizeY-LocationsY[o])) + LocationsX[o]) < ((Math.abs(GridSizeY-LocationsY[CornerXminYmax])) + LocationsX[CornerXminYmax]))||(CornerXminYmax == 0))
						{
							CornerXminYmax = o;		
						}
					
			else if(((Math.abs(GridSizeY-LocationsY[o])) + LocationsX[o]) == ((Math.abs(GridSizeY-LocationsY[CornerXminYmax])) + LocationsX[CornerXminYmax]))
							{
						
								if(LocationsX[o] < LocationsX[CornerXmaxYmin])
									{
										
									CornerXminYmax = o;	
									}
							
							}
											
	}


// adding the corner locations to the Multidist Array
//----------------------------------------------------------------------------
MultiDist[1] = CornerXminYmax;
MultiDist[2] = CornerXmaxYmax;
MultiDist[3] = CornerXmaxYmin;
MultiDist[4] = CornerXminYmin;



// removing double values from the Array:
//----------------------------------------------------------------------------

for(int r = 1; r <= 3; r++)
	{
		for(int b = (r+1); b <= 4; b++)
		{	
			if((MultiDist[r]==MultiDist[b])&&(r!=b))
				{
					if (r == 1)
						{
							if (b == 2)
							{
								if((((GridSizeX-1)-LocationsX[MultiDist[r]])+ ((GridSizeY-1)-LocationsY[MultiDist[r]]))<((Math.abs((GridSizeY-1)-LocationsY[MultiDist[r]])) + LocationsX[MultiDist[r]]))
								{
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
							if (b == 3)
							{
								if(((Math.abs((GridSizeX-1)-LocationsX[MultiDist[r]])) + LocationsY[MultiDist[r]])<((Math.abs((GridSizeY-1)-LocationsY[MultiDist[r]])) + LocationsX[MultiDist[r]]))
								{
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
							if (b == 4)
							{
								if((LocationsX[MultiDist[r]]+ LocationsY[MultiDist[r]]) < ((Math.abs((GridSizeY-1)-LocationsY[MultiDist[r]])) + LocationsX[MultiDist[r]]))
								{
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
						}
					if (r == 2)
						{	
						if (b == 3)
							{
								if(((Math.abs((GridSizeX-1)-LocationsX[MultiDist[r]])) + LocationsY[MultiDist[r]]) < (((GridSizeX-1)-LocationsX[MultiDist[r]])+ ((GridSizeY-1)-LocationsY[MultiDist[r]])))
								{	
										
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
							if (b == 4)
							{
								if((LocationsX[MultiDist[b]]+ LocationsY[MultiDist[b]]) < (((GridSizeX-1)-LocationsX[MultiDist[r]])+ ((GridSizeY-1)-LocationsY[MultiDist[r]])))
								{
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
						}
					
					if (r == 3)
						{
							if (b == 4)
							{
								if( ((Math.abs((GridSizeX-1)-LocationsX[MultiDist[b]])) + LocationsY[MultiDist[b]]) < (LocationsX[MultiDist[r]]+ LocationsY[MultiDist[r]]))
								{
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
						}
	
				}
		}
	}





// checking for additional border points
//----------------------------------------------------------------------------

CornerXminYmax = MultiDist[1];
CornerXmaxYmax = MultiDist[2];
CornerXmaxYmin = MultiDist[3];
CornerXminYmin = MultiDist[4];

for (int o = 1; o<=(target_amount);o++)
			{
			
			//if ((LocationsY[o] < LocationsY[CornerXminYmax])&&(LocationsX[o] < LocationsX[CornerXminYmax])&&(LocationsY[o]!=0)
			//	{
			//	MultiAdder(0,o);	
			//	}	
			
			
			if((LocationsY[o] >= LocationsY[CornerXmaxYmax])&&(LocationsX[o] < LocationsX[CornerXmaxYmax])&&(LocationsX[CornerXminYmax] != LocationsX[o])) 
				{
				MultiAdder(1,o);		
				} 	
						
			if((LocationsX[o] >= LocationsX[CornerXmaxYmax])&&(LocationsY[o] < (LocationsY[CornerXmaxYmax]))&&(LocationsY[CornerXmaxYmin] != LocationsY[o])) 
				{
				MultiAdder(2,o);	
				}

			
			if((LocationsY[o] <= (LocationsY[CornerXmaxYmin]))&&(LocationsX[o] < LocationsX[CornerXmaxYmin])&&(LocationsX[CornerXminYmin] != LocationsX[o])) 
				{	
				MultiAdder(3,o);		
				}	
						

			}
			
// Multidist 0 Removal
//----------------------------------------------------------------------------			
for (int i = 1; i<=(target_amount+1);i++)
{
	if(MultiDist[i] == 0)
	{
		while((MultiDist[i] == 0)&&(CountKeeper<(target_amount+1)))
		{
		
				for(int f = i;f <= target_amount+1; f++  )
				{
				MultiDist[f] = MultiDist[f+1];
				MultiDist[f+1] = 0;	
				}
				CountKeeper++;
		}
	}
}

CountKeeper = 0;	

// checking which locations are not added to the MultiDist array	
//-----------------------------------------------------------------------------				

	for(int he = 1; he<=target_amount; he++)
		{
	
			boolean b_add = true;
	
			for(int v = 0; v <= target_amount; v++)
			{
				
				if (he == MultiDist[v])
				{
				b_add = false;	
				}
			}
	
			if (b_add == true)
			{
			CountKeeper++;
			NotMultiDist[CountKeeper] = he ;
			}
			
		}

	
//IMPORTANT!!!!!!!! Definitions of the starting Position of the Robot; not used further in the Solver
	LocationsX[0] = 0;
	LocationsY[0] = 0;
	



// Loop creates formulae between follow-up points in the Array "MultiDist" (Buffer Array for Final Array)
//-----------------------------------------------------------------------------	
	
	for( int i = 0; i <= (target_amount); i++)
		{


// Guide for formula creation between two defined points:
//+----------------------------------------------------------------------------------------------
//|
//| this statement creates a line formula to check the distance to the (several) remaining points
//| Y = a(X-c) + b		a = the multiplier;(y1-y2)/(x1-x2)
//| 					b = the distance from the starting point to the X-axis
//|						c = the distance from the starting point to the Y-axis
//|
//| NOTE: The coordinate with the smallest X is the start of the graph (otherwise creation was impossible)
//+-----------------------------------------------------------------------------------------------
			
			
			if(LocationsX[MultiDist[i]] < LocationsX[MultiDist[i+1]])
				{
				int c = LocationsX[MultiDist[i]];
				int b = LocationsY[MultiDist[i]];

				float a1 = (LocationsY[MultiDist[i]]-LocationsY[MultiDist[i+1]]);
				float a2 = (LocationsX[MultiDist[i]]-LocationsX[MultiDist[i+1]]);
				float a = a1 / a2;
				
				boolean isNinetyDegrees = false;
				System.out.println(" (<) The Formula between the coordinates " + MultiDist[i] + " and " + MultiDist[(i+1)] + " is: Y = " + a + "X + " + b);
				
				FinalAdd(LocationsX[MultiDist[i]],LocationsX[MultiDist[i+1]], a, b, c, i, isNinetyDegrees);
			
				}
	
			
			
			
			else if(LocationsX[MultiDist[i+1]] < LocationsX[MultiDist[i]])
				{
				int c = LocationsX[MultiDist[i+1]];
				int b = LocationsY[MultiDist[i+1]];
				
				float a1 = (LocationsY[MultiDist[i]]-LocationsY[MultiDist[i+1]]);
				float a2 = (LocationsX[MultiDist[i]]-LocationsX[MultiDist[i+1]]);
				float a = a1 / a2;
				
				boolean isNinetyDegrees = false;
				System.out.println(" (>) The Formula between the coordinates " + MultiDist[i] + " and " + MultiDist[(i+1)] + " is: Y = " + a + "X + " + b);
				
				 FinalAdd(LocationsX[MultiDist[i+1]],LocationsX[MultiDist[i]], a, b, c, i, isNinetyDegrees);
				}
			
			
			
			
			
			else if((LocationsX[MultiDist[i+1]] ==  LocationsX[MultiDist[i]])&&((MultiDist[i]!=0)||(MultiDist[i+1]!=0)))
				{
// Should the coordinate's x be the same for both locations; a graph creation would be impossible
					int c = 0 ;
					int b = 0 ;
					float a = 0 ;
					boolean isNinetyDegrees = true;
					
					System.out.println("equal X from " + MultiDist[i] + " and " + MultiDist[i+1]);
					
					if(LocationsY[MultiDist[i+1]] > LocationsY[MultiDist[i]])
						{
						FinalAdd(LocationsY[MultiDist[i]],LocationsY[MultiDist[i+1]], a, b, c, i, isNinetyDegrees);
						}
					else
						{
						FinalAdd(LocationsY[MultiDist[i+1]],LocationsY[MultiDist[i]], a, b, c, i, isNinetyDegrees);
						}
			
			

						
			
				
				
				}
			else
				{
// In case of an graph generation error:
			System.out.println("No Comply from " + MultiDist[i] + " and " + MultiDist[i+1]);
				}
		}
			
		
			
			
			
		 	
		 	for(int d = 0; d<= (target_amount+4); d++)
				{
				CurrZeroDist[d] = 0;
				}
							
							
								
// RecurPointer Points towards the starting location of the graph's data in the array
//-----------------------------------------------------------------------------		 
			RecurCounter = 0;
			
			for(int d = 0; d<= (ThaBigOne.length-1); d++)
				{
					if(ThaBigOne[d] == "<<STRT>>")
							{

							RecurPointer[RecurCounter] = (d + 1);
							RecurCounter++;
							}
				}
							





//Array Dissimulation (ThaBigOne )
//-----------------------------------------------------------------------------

for(int g = 0; g <FinalArray.length; g++)
	{
	FinalArray[g] = 0;	
	} 

						
// Guide for the Array Dissimulating loop:
//+-------------------------------------------------------------------------------------------+
//|
//|
//|
//| RecurPointer:             [A],                    		[B],
//|							   |                      		 |
//|	ThaBigOne:   	  <<STRT>>,A,B,C,D,E,C,D,E,C,D,E,<<STRT>>A,B,.........
//|
//| A = Strart of the graph to which the target distance is checked
//| B = Index for targets being checked (amount)
//| C = target being checked (the point you click on at the start of the program)
//| D = distance from the target to the graph; checked from (Xtarget-0,5) to (Xtarget+0,5)
//| E = distance to the starting point of the graph from the target
//+-------------------------------------------------------------------------------------------+
	
	
// (1) What Location in the NotMultiDist Array to check? value NotMultiDist[0] - NotMultiDist[NotMultiDist.length-1]	
	
	
	for(int NotMultiDistNr = 1; NotMultiDistNr <= CountKeeper; NotMultiDistNr++)
		{
						float ClosestTo = 0;
						int OrderByDistanceToLine = 0;
						int StartingPointInArray = 0;	
		
			
// (2) Indicates where to start in the Distance Array
			for( int DistIndx = 0; DistIndx < RecurCounter; DistIndx++)
					{
						
// (3) Indicates for how long to repeat checking for coords (uses B)
									;
						for( int repeatIndx = 0; repeatIndx <= Integer.parseInt(ThaBigOne[((RecurPointer[DistIndx])+1)]); repeatIndx++)
							{
		
// (3.1) Checks whether the requisted target is added to the array								
								if( (Integer.parseInt(ThaBigOne[(RecurPointer[DistIndx])+2 +(repeatIndx*3)])) == NotMultiDist[NotMultiDistNr])
									{

// (3.2) Changes the smallest value for the target to the current distance?												
												if( (Float.parseFloat(ThaBigOne[(RecurPointer[DistIndx])+(repeatIndx*3)+3])< ClosestTo)|| (ClosestTo == 0))
													{	

													ClosestTo = Float.parseFloat(ThaBigOne[(RecurPointer[DistIndx])+(repeatIndx*3)+ 3]);
													StartingPointInArray = Integer.parseInt(ThaBigOne[RecurPointer[DistIndx]]);
													OrderByDistanceToLine = Integer.parseInt(ThaBigOne[(RecurPointer[DistIndx])+(repeatIndx*3)+ 4]);
													}
													
// (3.2.1) In the unlikely event two distances may be the same..
									}
								
							}
							




// (4) at the end of the loop the target is placed on the right place of the Buffer Array							
//-----------------------------------------------------------------------------								


// Guide for using the CurrZeroDist Array:
//+-------------------------------------------------------------------
//|
//|						   <b>  
//|							|  
//|CurrZeroDist: ,  ,  ,  , a,  ,  ,..... 
//|							|  
//|FinalArray  :0,e1,e2,e3,  ,e4,e5, ....
//|
//|a = location nearest to the graph e3, placed at FinalArray[e3+1] when CurrZeroDist is complete
//|    (var StartingPointInArray+1 used for point in array)
//|b = Possibly, there are more locations closest to graph e3, they are sorted on distance towards
//|    the starting loc of the graph (point e3), and form thearray <b>
//|NOTE = the length of b should be added to any follow up point in the CurrZeroDist array to prevent
//|    problems (done by the FinalArray array)
//+-------------------------------------------------------------------

			if ((DistIndx == (RecurCounter-1))&&(NotMultiDist[NotMultiDistNr]!= 0))
						{


//----------------------------------------------------------------------------------------------------------
// !!!!!!!!!!!!!!!!!!WARNING: DO NOT MESS AROUND WITH!!!!!!!! VERY DELICATE AND DIFFICULT CODING!!!!!!!!!!!!!!!!
//----------------------------------------------------------------------------------------------------------



							
							
							for (int zak = (target_amount); zak > (StartingPointInArray + FinalArray[StartingPointInArray+1]); zak--)
													{
													CurrZeroDist[zak] = CurrZeroDist[zak-1];
													CurrZeroDist[zak-1] = 0;
													
													youBetterThenMe[zak] = youBetterThenMe[zak-1];
													youBetterThenMe[zak-1] = 0;
													}
	
							
									
							if (youBetterThenMe[(StartingPointInArray + FinalArray[StartingPointInArray+1])]== 0)
								{ 

										if (CurrZeroDist[((StartingPointInArray) + 2 + (FinalArray[StartingPointInArray+1]))] != 1024)
											{
												
												for( int checkIt = (StartingPointInArray + 2 + FinalArray[StartingPointInArray+1]); checkIt <=  ((StartingPointInArray) + 2 + (FinalArray[StartingPointInArray+1])) +(FinalArray[StartingPointInArray+2]-FinalArray[StartingPointInArray+1]); checkIt++)
													{
														
														
														if ((youBetterThenMe[checkIt] < OrderByDistanceToLine) && (youBetterThenMe[checkIt]!= 0))
																{
																CurrZeroDist[checkIt-1] = CurrZeroDist[checkIt];
																CurrZeroDist[checkIt] = 0;
													
																youBetterThenMe[checkIt-1] = youBetterThenMe[checkIt];
																youBetterThenMe[checkIt] = 0;
																}
														
														
													else if ((youBetterThenMe[checkIt] >= OrderByDistanceToLine) && (youBetterThenMe[checkIt]!= 0))
																{
																
																CurrZeroDist[checkIt-1] = NotMultiDist[NotMultiDistNr];
																youBetterThenMe[checkIt-1] = OrderByDistanceToLine;
																break;
																}
																
													else if (youBetterThenMe[checkIt] == 0)
																{
																
																CurrZeroDist[checkIt-1] = NotMultiDist[NotMultiDistNr];
																youBetterThenMe[checkIt-1] = OrderByDistanceToLine;
																break;
																}
															
															else 
																{
																	System.out.println( "Critical exception for coord" + NotMultiDist[NotMultiDistNr] + "at" + checkIt);
																}
															
															
													}
													
											System.out.println(" target " + NotMultiDist[NotMultiDistNr] + " is part of the " + MultiDist[StartingPointInArray] + " - "+MultiDist[StartingPointInArray+1] + " group with lenght " + (FinalArray[StartingPointInArray+2]-FinalArray[StartingPointInArray+1]));
											}
										
										
										
										else if(youBetterThenMe[((StartingPointInArray) + 2 + (FinalArray[StartingPointInArray+1]))]== 0)
											{
												CurrZeroDist[(StartingPointInArray+1 + FinalArray[StartingPointInArray+1])] = NotMultiDist[NotMultiDistNr];
												youBetterThenMe[(StartingPointInArray+1 + FinalArray[StartingPointInArray+1])] = OrderByDistanceToLine;
											}
								
								}	
								else 	
								{				
					
									
							    }

						for (int zak = (target_amount+1); zak > (StartingPointInArray+1); zak--)
								{
								FinalArray[zak] = FinalArray[zak] + 1;	
													
								}
					
						
						
						CurrZeroDist[0]= 0;
				
			
				
				}
							
							
			}
				

		}
		

//----------------------------------------------------------------------------------------------------------
//                            !!!!!!!!!!!!!!!!!!END OF HARD CODING STUFF!!!!!!!!!!!!!!!!
//----------------------------------------------------------------------------------------------------------

for(int g = 0; g <FinalArray.length; g++)
	{
	FinalArray[g] = 0;	
	} 



// inserting the spare targets
//-----------------------------------------------------------------------------
		System.out.print("MULTIDIST : ");
				for(int tero = 0; tero < (target_amount+1); tero++)
								{
							System.out.print(MultiDist[tero] + " ");
								}
				System.out.println("");
	
	
	
	
		System.out.print("BUFFER ARRAY: ");
				for(int tero = 0; tero < (target_amount+1); tero++)
								{
							System.out.print(CurrZeroDist[tero] + " ");
								}
				System.out.println("");
				
				
				System.out.print("VALUE BUFFER; ");
				for(int tero = 0; tero < (target_amount+1); tero++)
								{
								System.out.print( + youBetterThenMe[tero] + " ");	
								}
			System.out.println("");		
				System.out.println("=====================================================================");

//----------------------------------------------------------------------------
// optional trace to check the clicked coords
		for (int b = 1; b<= this.target_amount; b++) 
			{
			System.out.println( "Location " + (b) + ": " + LocationsX[b] + " " + LocationsY[b]);
			
			}
			
			
			
int torn = 0;

	
	for(int gaar = 0; gaar <= (target_amount+1); gaar++)
		{
			
			 	if (CurrZeroDist[gaar] == 0)
					{	
							
						FinalArray[gaar] = MultiDist[torn];
						torn++;

						//	System.out.println("No Value:  " );
							
						//	for(int tero = 0; tero < (target_amount+2); tero++)
						//		{
						//		System.out.print(FinalArray[tero] + " ");	
						//		}
						//		
						//	System.out.println("");
							
					}
			
				else if(CurrZeroDist[gaar]!= 0)
					{
						FinalArray[gaar] = CurrZeroDist[gaar];
					//		
					//		System.out.println("Value is there: " );
					//		for(int tero = 0; tero < (target_amount+3); tero++)
					//			{
					//			System.out.print(FinalArray[tero] + " ");	
					//			}
					//			
					//		System.out.println("");
							
							
					}
					
						
						
						
						
						
						
				}
							
		FinalArrange();	

}




//----------------------------------------------------------------------------------------------------------
/*€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
		€€€€€		€€€€€€		€€€€€€		€€€€€€		€€€€€€		€€€€€€
	€€	  	€€		€€		€€		€€		€€		€€		€€		€€		€€

									"THE END"


	€€		€€		€€		€€		€€		€€		€€		€€		€€		€€
  €€€€€€	 €€€€€€      €€€€€€       €€€€€€      €€€€€€     €€€€€€       €€€€€€	
  €€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€
*/
//----------------------------------------------------------------------------------------------------------














//----------------------------------------------------------------------------------------------------------
// function to add points in the first generation MultiDist Array()
//----------------------------------------------------------------------------------------------------------


void MultiAdder(int PointinArray, int o)
{
	System.out.print("MULTIDIST   ");
					
					
					for(int r = 0; r < target_amount+5; r++)
						{
						System.out.print(MultiDist[r] + " ");
						}
					System.out.println("");	
				
				
				
					for(int i = 4; i > PointinArray; i--)
					{
					FinalArray[i] = FinalArray[i] + 1;		
					}
					
					
					
					
					for(int i = target_amount; i > (PointinArray+1+FinalArray[PointinArray]); i--)
					{
					MultiDist[i] = MultiDist[i-1];
					MultiDist[i-1] = 0;	
					}



// Case: Their are no coords added between these two points
//---------------------------------------------------------------------------------------------------					
	if((FinalArray[PointinArray+1] - FinalArray[PointinArray])==1)
	{
		
		System.out.println("CASE: Their are no coords added between these two points" + o);	
		MultiDist[PointinArray +1+ FinalArray[PointinArray]] = o;
	
	//------------------------------------------------				
						
					System.out.print("FinalArray ");
					for(int r = 0; r < 5; r++)
						{
						System.out.print(FinalArray[r] + " ");
						}
					System.out.println("");	
					
					System.out.print("MULTIDIST   ");
					for(int r = 0; r < target_amount + 5; r++)
						{
						System.out.print(MultiDist[r] + " ");
						}
					System.out.println("");	
					System.out.println("");	
				
				
	//------------------------------------------------			
	}
	
// Case: Their ARE coords added between these two points
//---------------------------------------------------------------------------------------------------						
	else if((FinalArray[PointinArray+1] - FinalArray[PointinArray])>1) 
	{
		System.out.println("CASE: Their ARE coords added between these two points" + o);
					
					boolean BreakYou = false;
					
					for(int i = (PointinArray + 2 + FinalArray[PointinArray]); i <= (PointinArray+1) + FinalArray[PointinArray] + ((FinalArray[PointinArray+1] - FinalArray[PointinArray])-1);i++)	
						{
					
					System.out.println("");	
					System.out.print("CHECKING POINT: " + MultiDist[i]);
					System.out.println("");	
							
					if (BreakYou == false)	
					{
					
					
// o = Nearer					
//-----------------------------------------------------------------------------						
						if ((((Math.abs(LocationsX[o]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[o]-LocationsY[MultiDist[PointinArray]])) )<((Math.abs(LocationsX[MultiDist[i]]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[MultiDist[i]]-LocationsY[MultiDist[PointinArray]])) ))&&(MultiDist[i]!=0))
							{
							MultiDist[i-1] = o;
							System.out.print(o + " is Nearer then " + MultiDist[i]);
							BreakYou = true;
								
							}
							
// o = Equal							
//-----------------------------------------------------------------------------								
						else if ((((Math.abs(LocationsX[o]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[o]-LocationsY[MultiDist[PointinArray]])) )==((Math.abs(LocationsX[MultiDist[i]]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[MultiDist[i]]-LocationsY[MultiDist[PointinArray]])) ))&&(MultiDist[i]!=0))
							{
								if(LocationsX[o]< LocationsX[MultiDist[i]] )
								{
								MultiDist[i-1] = o;
								
								System.out.print(o + " is equal to " + MultiDist[i]);
								BreakYou = true;	
								}
								
								else
								{
								MultiDist[i] = MultiDist[i-1];	
								}
								
								
								
								
							}
// o = Further							
//-----------------------------------------------------------------------------								
						else if ((((Math.abs(LocationsX[o]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[o]-LocationsY[MultiDist[PointinArray]])) )>((Math.abs(LocationsX[MultiDist[i]]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[MultiDist[i]]-LocationsY[MultiDist[PointinArray]])) )))
							{
								if (MultiDist[i]!=0)
								{
								MultiDist[i-1] = MultiDist[i];
								MultiDist[i] = 0;	
								System.out.print(MultiDist[i-1] + " Has been moved");
								}
								
								if(i ==((PointinArray+1)+((FinalArray[PointinArray+1] - FinalArray[PointinArray])-1)))
									{
									MultiDist[i] = o;
									System.out.print(o + " is further " + MultiDist[i-1]);
									BreakYou = true;	
									}
							}
							
						
						}
						
						}
						
					
					
				//------------------------------------------------				
						System.out.println(" ");
					System.out.print("FinalArray");
					for(int r = 0; r < 5; r++)
						{
						System.out.print(FinalArray[r] + " ");
						}
					System.out.println("");	
					
					System.out.print("MULTIDIST");
					for(int r = 0; r < target_amount + 5; r++)
						{
						System.out.print(MultiDist[r] + " ");
						}
					System.out.println("");	
					
				
				System.out.println("LeftTop - RightTop: " + o);	
				//------------------------------------------------		
			}	
				
}










//----------------------------------------------------------------------------------------------------------
// function to add the final wayward points (called by function AlgorithmS2)
//----------------------------------------------------------------------------------------------------------

void FinalAdd(int XlocMin,int XlocMax,float a,int b,int t, int route, boolean IsNinetyDegrees)
{
	int valuetrue = 0;
	int houdbij = 0;
	



	for(int c = 0; c <= target_amount; c++)
	{
					if(IsNinetyDegrees==false)
					{
							if( ( XlocMin <= LocationsX[NotMultiDist[c]]) && (LocationsX[NotMultiDist[c]] <= XlocMax) && (NotMultiDist[c] != 0))
							{
							valuetrue++;
							float gek;
				
// Syntax for the Distance array:
//+--------------------------------------------------------------------------------------------------------
//|		1) Distance[a] 	=  		segment starts of with the <<STRT>> command, this devides the outcomes for different graphs
//|		2) Distance[a+1]=  		contains the calling graph (<ted> variable in the AlgorithmS2 function)
//|		3) Distance[a+2]=		contains the index for the graph		
//|		3) Distance[(a+3)*b]= 	Value of the coord being checked, b indicates index place
//|		4) Distance[(a+4)*b]=	Distance from the graph to the coord
//| 	5) Distance[(a+5)*b]=	Distance from the starting point of the graph to the target
//+------------------------------------------------------------------------------------------	



// checks whether it has to make a new devision in the Distance[] array 
							if (valuetrue == 1)
								{
								ThaBigOne[RecurCounter] = "<<STRT>>";
								RecurCounter++;
								ThaBigOne[RecurCounter] = Integer.toString(route);
								RecurCounter++;
								houdbij = RecurCounter;
								RecurCounter++;
			
								}
				
				
// checks the actual distance to the graph that called the function (uses base X of the point)				
				 				
				 				float gek1 =  (LocationsY[NotMultiDist[c]]);
				 				float gek2 = (LocationsX[NotMultiDist[c]]- t);
				 				float gek3 = b;
				 		
				 				
				 				gek =Math.abs( gek1 - ((a * gek2) + gek3) );




// checks whether the graph is nearer +0.5X and -0.5X; reduces the chance for simular values	
				 			
				 					
				 				 gek2 = LocationsX[NotMultiDist[c]]- t + ((float) 0.5);

				 			
				 				if ( (Math.abs( gek1 - ((a * gek2) + gek3)) < gek) && (( XlocMin <= (LocationsX[NotMultiDist[c]]+0.5)) && ((LocationsX[NotMultiDist[c]]+0.5) <= XlocMax))  )
									{
									gek =Math.abs( gek1 - ((a * gek2) + gek3));
									}
							

				 				 gek2 = LocationsX[NotMultiDist[c]]- t - ((float) 0.5);

						
				 				if ( (Math.abs( gek1 - ((a * gek2) + gek3)) < gek) && (( XlocMin <= (LocationsX[NotMultiDist[c]]-0.5)) && ((LocationsX[NotMultiDist[c]]-0.5) <= XlocMax))  )
									{
									gek =Math.abs( gek1 - ((a * gek2) + gek3));
									}
				
				
				
								ThaBigOne[RecurCounter] = Integer.toString(NotMultiDist[c]);
								RecurCounter++;
								ThaBigOne[RecurCounter]= Float.toString(gek);
								RecurCounter++;
								ThaBigOne[RecurCounter]=  Integer.toString( (Math.abs(Math.abs(LocationsX[NotMultiDist[c]])-Math.abs(LocationsX[MultiDist[route]]))) + (Math.abs(Math.abs(LocationsY[NotMultiDist[c]])-Math.abs(LocationsY[MultiDist[route]]))  ) );
								RecurCounter++;



				System.out.println("The Distance from " + NotMultiDist[c] + " to this Formula is: " + gek);


				
				
							}
		
					}
					
					
					
// In case of a vertical line (i.e. no graph would be possible
			else if(IsNinetyDegrees==true)
					{
					if( ( XlocMin <= LocationsY[NotMultiDist[c]]) && (LocationsY[NotMultiDist[c]] <= XlocMax) && (NotMultiDist[c] != 0)&&((LocationsX[MultiDist[t]]!=0)||(LocationsY[MultiDist[t]]!=0)||(LocationsY[MultiDist[t+1]]!=0)||(LocationsX[MultiDist[t+1]]!=0)))
							{
							
							
							valuetrue++;
							float gek;
							
							System.out.println(LocationsX[MultiDist[t]] +  " - " + LocationsX[NotMultiDist[c]] );
							
							System.out.println(NotMultiDist[c] + "got trough");
							
										if (valuetrue == 1)
											{
											ThaBigOne[RecurCounter] = "<<STRT>>";
											RecurCounter++;
											ThaBigOne[RecurCounter] = Integer.toString(route);
											RecurCounter++;
											houdbij = RecurCounter;
											RecurCounter++;
											}
							
								if((LocationsX[NotMultiDist[c]] == LocationsX[MultiDist[t]]))
									{
										gek =(float) 0.01;	
									}
								else
									{
										gek =(float)(Math.abs(LocationsX[NotMultiDist[c]]-LocationsX[MultiDist[t]]));  
									}
							
								
							
								
							ThaBigOne[RecurCounter] = Integer.toString(NotMultiDist[c]);
							RecurCounter++;
							ThaBigOne[RecurCounter]= Float.toString(gek);
							RecurCounter++;
							ThaBigOne[RecurCounter]=  Integer.toString( (Math.abs(Math.abs(LocationsX[NotMultiDist[c]])-Math.abs(LocationsX[MultiDist[route]]))) + (Math.abs(Math.abs(LocationsY[NotMultiDist[c]])-Math.abs(LocationsY[MultiDist[route]]))  ) );
							RecurCounter++;
							
							}
					}

//creating an index for this section of the array			
			if ((c == target_amount) && (valuetrue>0))
					{
					ThaBigOne[houdbij] = Integer.toString(valuetrue-1); 
					
				//		System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");		
							for(int tero = 0; tero <= RecurCounter-1; tero++)
								{
				//	System.out.println("Pre-use Calculation Array: "+ 	ThaBigOne[tero] );
								}
								
					}	
	
	
	
		}
	

 }
 
//--------------------------------------------------------------------------------------------------------------------
// function to remove crossing of previous locations & Erronous route repair (Even so, errors probably still remain)
//--------------------------------------------------------------------------------------------------------------------
 
 void FinalArrange()
	{
	
	float BaseDistance = 0;
	int Replacer;
	float DistanceChecker = 0;
	
		for(int g = 0; g < (target_amount+1);g++)
		{
   		BaseDistance = BaseDistance + ( (float) (Math.sqrt(((Math.abs(LocationsY[FinalArray[g]]-LocationsY[FinalArray[g+1]]))*(Math.abs(LocationsY[FinalArray[g]]-LocationsY[FinalArray[g+1]]))) + ((Math.abs(LocationsX[FinalArray[g]]-LocationsX[FinalArray[g+1]]))*(Math.abs(LocationsX[FinalArray[g]]-LocationsX[FinalArray[g+1]]))))  ));
		}
	
	
	System.out.println("***************** After Calculation Error Repair *******************");	
	System.out.println("Crossed Distance: " + BaseDistance);
	


// in case of Erronous starting Point 
//-----------------------------------------------------------------------------		
		for(int g = target_amount+3; g >= 1;g--)
			{
			FinalArray[g] = FinalArray[g-1];			
			}
		
		 	FinalArray[1] =  FinalArray[target_amount+1];
		 	FinalArray[target_amount+1] = 0;
		 
		 	DistanceChecker = 0;
		
			for(int g = 0; g < (target_amount+1);g++)
				{
   				DistanceChecker = DistanceChecker + ( (float) (Math.sqrt(((Math.abs(LocationsY[FinalArray[g]]-LocationsY[FinalArray[g+1]]))*(Math.abs(LocationsY[FinalArray[g]]-LocationsY[FinalArray[g+1]]))) + ((Math.abs(LocationsX[FinalArray[g]]-LocationsX[FinalArray[g+1]]))*(Math.abs(LocationsX[FinalArray[g]]-LocationsX[FinalArray[g+1]]))))  ));
				}
		
		System.out.println("DistanceChecker: " + DistanceChecker);
		
					if(DistanceChecker >= BaseDistance)	
						{
								System.out.println( "Restoring to base output (DistanceChecker >= BaseDistance)....");
								System.out.println("");
								
		 						FinalArray[target_amount+1] = FinalArray[1];	
					
							for(int h = 1; h < target_amount+2;h++)
								{
								FinalArray[h] = FinalArray[h+1];
								System.out.println(h + " restored - " + FinalArray[h]);			
								}
						
						}
					else
						{
						BaseDistance = DistanceChecker;
						System.out.println("checked "+ (target_amount+1)  + "(" +  LocationsX[FinalArray[1]] + " " + LocationsY[FinalArray[1]] + ") and 1 (" +  LocationsX[FinalArray[2]] + " " + LocationsY[FinalArray[2]] + ") NEW Crossed Distance: " + DistanceChecker);
						}
				
		 
		 		System.out.print("Export Array : ");
				for(int g = 0; g < (target_amount+2); g++)
								{
							System.out.print(FinalArray[g] + " ");
								}
				System.out.println("");
		 	
// in case of crossing lines
//-----------------------------------------------------------------------------		
	
for(int i = 0; i <2; i++)
	{	
	for(int g = 2; g < (target_amount+3);g++)
		{
		 
		 DistanceChecker = 0;
		 Replacer =	FinalArray[g];
		 FinalArray[g] =  FinalArray[g+1];
		 FinalArray[g+1] = Replacer	;
			
		
			for(int h = 0; h < (target_amount+3);h++)
				{
   				DistanceChecker = DistanceChecker + ( (float) (Math.sqrt(((Math.abs(LocationsY[FinalArray[h]]-LocationsY[FinalArray[h+1]]))*(Math.abs(LocationsY[FinalArray[h]]-LocationsY[FinalArray[h+1]]))) + ((Math.abs(LocationsX[FinalArray[h]]-LocationsX[FinalArray[h+1]]))*(Math.abs(LocationsX[FinalArray[h]]-LocationsX[FinalArray[h+1]]))))  ));
				}
				
				System.out.println("BaseDistance: " + BaseDistance );
					if(DistanceChecker >= BaseDistance)	
						{
								
						Replacer =	FinalArray[g];
		 				FinalArray[g] =  FinalArray[g+1];
		 				FinalArray[g+1] = Replacer;	
		 				
		 				System.out.println(DistanceChecker);
						System.out.println("checked "+ g + "(" +  LocationsX[FinalArray[g]] + " " + LocationsY[FinalArray[g]] + ") and " + (g+1) + "(" +  LocationsX[FinalArray[g+1]] + " " + LocationsY[FinalArray[g+1]] + ") ;No Improvement");
					
						}
					else
						{
							BaseDistance = DistanceChecker;
						System.out.println("checked "+ g + "(" +  LocationsX[FinalArray[g]] + " " + LocationsY[FinalArray[g]] + ") and " + (g+1) + "(" +  LocationsX[FinalArray[g+1]] + " " + LocationsY[FinalArray[g+1]] + ") NEW Crossed Distance: " + DistanceChecker);
						System.out.println(Replacer);
						
						System.out.println(FinalArray[g]);
						System.out.println(FinalArray[g+1])	;
						}
	
		}
		
		
		for(int h = 0; h < (target_amount+3);h++)
				{
   				if ((FinalArray[h] == 0)&&(h!=0))
					{
						System.out.println("0 found at:" + h );
					
						for(int j = h; j < (target_amount+5);j++)
							{
								
								FinalArray[j] = FinalArray[j+1];
								FinalArray[j+1] = 0;	
							}
				
					}
				}
		System.out.println("target_amount: " + target_amount);
		
		System.out.print("Export Array : ");
				for(int g = 0; g < (target_amount+5); g++)
								{
							System.out.print(FinalArray[g] + " ");
								}
				System.out.println("");
		

 		}
 
 	}
 
}