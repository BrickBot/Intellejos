/*



ллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
        ммВВппппВм                  ммммм
       ллВн       плмм           млллллпппВмм                 мммммммм
        пплмм       плллммм   м ллллп       пВм      ммммВВВлпппллллллллВм
         ммўппп       пллллВВп  пллн         онпВллллллпппмммлппп      плВВм
 мВВВВм ллн       ммллммплллн     пВм       мп   пплмммппВпп ммм        оллллм
он  ппВВмлл   ммлллллл плВлллмм      ппп пп   мммллллллп  ммллллллмм   млллллл
 пўм   пп ммлмолллллллн    пппВллллммммммлллВВлллллллл  мллллллпплллпмллллпплмВ
      ммВВВпплллВВллллллмм        ппВлллппп  ллллллллпмллллллп   олВлВппммллллп
   мВВВппммВВлллн ппВВллллллм  ммлллллм     олллллллнолллллл     оВлммллппп
 млллл    ллллллл    пВлллллллмоллллллВ      ллллллл ллллллн   мВлппп мммм
Вллллн    оллллллн    олллллллВнлллллллм     олллллл оллллллм    ммВВлллллллм
лллллн    оллллллн    олллллллпоВлллллллм     ллллллн пллллллллллппппллллллллВ
пллллВм   оллллллВ   мллллллп  оВллллАллллм   олллллл    пппп   мм     пллллллВ
  плллВВммллллллллммлВВВпп     ВВллллн плВВлм  Влллллн      ммллп       олллллл
      ппплллллллллВВммм       млВллллн   пллллмолллллл мммлллп          олллллл
        оллллллллплллллллВммм   ппплл       ппллВлллллнлллллн           лллллл
     мммлллллллп   пппллллллллллллмммммм        пплВлллмпллллм        мллллВВ
   мллпп    пппВВВмм      ппппллллллллллллллллммм    пппВммпплВВмммллллВллВВ
  Вллн             пВм            ппплллллллллллллм мммммммлллллллмБВлллппп
   пВВм             оллм  ммллВп ўмм   плллллллллллллВпп    ппппллллллллллмм
     пллВмм        мллллнлВлллн    пВВм оллллллллпп  Б       ммў   пплллллллн
    мВВВлллллллллллллллп плллллмм   оллллллВВпп      А ммммВВВн      олллллп
   п мВпппмВпллВппппп       ппппллллммммммммммммммллллппп   ппВм    мВВВпп
  мллп     Вллллм                  ппппппппппппппп   ммммммм    ппммм
 лллн      оллнпВлм              мВВВВп         ммВВлпппВппллллмм  пплллмм
  пплллпллллллп пмм                                            ммп плллллм
       оллллл    олВ    Nacor & Pieter Weterings Present:     Влн    лллллн
       лллллн    лллн                                        оллл    оллллл
       плллллм  ВллВ      "DH153 - Team 3 - Solver v 3.2"      ВллВ  млллллп
         пплллллллп                                            плллллллпп
          млллллп         									   	плллллм
        млллллп пмм           									ммп плллллм
       оллллл    олВ                                В			лн    лллллн
       лллллн    лллн                                        оллл    оллллл
       плллллм мВллВ   млллВВмм                    ммВВлллм   ВллВм млллллп
         пплллллллп ммллп    пллм                мллп    пллмм плллллллпп
           млллплмллпп       мллпммммм      мммммпллм       ппллмлплллм
        мллллллллппВВВмммлллллВллппппллм ммллппппллВлллллмммВВВппллллллллм
      млллллпмллн      ппппплллм      пллллп      млллппппп      оллмплллллм
     млллллноллллм      мммлллппллмммлллпллллмммллпплллммм      мллллнолллллм
     ллллллн плллллмммлллллп      лллпп    ппллл      плллллмммлллллп олллллл
      ппллллмм пплллллллпп    ммлпп            пплмм    пплллллллпп ммллллпп
           пплллммм     мммлВпп                    ппВлммм     мммлллпп
               лллн       олн     ммлп   л   плмм     олн       оллл
                пллм     млп мммллпп    ллл    ппллммм плм     мллп
                  ппллмллллллппп       Влллл       пппллллллмллпп
                      пппп            олллллл            пппп
                                      лллллллл
                                     лллллмлллн
                                    олллллноллл
                                    ллллллмллллн
                                    лллллноллллл
                                    лллллнВллллл
           плВпммммм                лллллАлллллл
             пВВллллллллмм          оВлллАлллллл               мммммпВлп
               плллллллпплллмм       Влллллллллл         ммллллллллВВп
                 пллллллллмлппллмм   плллнолллВн     ммлллпплллллллп
                   плллллллллллплллм  ВллноллВВ  ммллпплмллллллллп
                     пллллллллллммпплм Влл лВВн лллплллллллллллп
                        плллллллллллплл ВВ ВВмллпммллллллллллп
                          пплллллллллмлноВлВнлВВллллллллллп
                мммммммммммм   пплллллм ллВВлмлллллллллпп
         ммммлллллллллллллллллллмммВВпВмллллмлллллпп   мммммммммммм
 ммммллллллллллппммммпппппппВВВлллллллллВВВмВпВВмммлллллллллллллллллллмммм
  плллВВВллллллллВВВллллллллммммммммплплммллплпВВВппппппппммммммммппплпллллллмм
      пппВВВлллллллВВВВлллллллппп ммпмллллллмплмм пппллллллллллллллллллллппп
             пппппппппп       ммллплллпплллплмпллллмм       пппппппп
                            млллллллл   ллл  ллмплллллм
                           млллллллп    ллн   пллллллллм
                           ллллппп     оллн      ппплллл
                                       оллл
                                        ллВ
                                        олВн
                                         пВлм
                                            пп
лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл


 */
 
// Imports
//----------------------------------------------------------------------------
 
		import javax.swing.*;
		import java.awt.*;
		import java.awt.event.*;





public class DH153_Team3_Solver_3_2 implements Solver 
	{
  
  
public boolean Answer = false;
  		


public int [] LocationsXDone = new int [100];
public int [] LocationsYDone = new int [100];
public int Target_Amount = 0;
  

     
    public static void main(String[] args) 
    	{
        DH153_Team3_Solver_3_2 broodjeBanaan = new DH153_Team3_Solver_3_2();
        
  
        
// PizzaViewer        
        new PizzaViewer(broodjeBanaan);

    	}



//----------------------------------------------------------------------------       	    
// Creates a new instance of DH153_Team3_Solver_3_# 
//----------------------------------------------------------------------------
    public DH153_Team3_Solver_3_2()  
    	{
    		
    	}

	public boolean AreWeThereYet()
		{
		return Answer;	
		}

	


//-----------------------------------------------------------------------------    
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Main Solver Function
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++    

  	public PointP[] computeRoute(PointP[] cities) 
    	{  
	
		BananaClass bananaclass = new BananaClass();
		bananaclass.target_amount = (cities.length-1);	
		bananaclass.GridSizeX = PizzaPanel.COLS;
		bananaclass.GridSizeY = PizzaPanel.ROWS;
		Target_Amount = cities.length;	
    	PointP[] route = new PointP[cities.length];
       

// Preparation of variables				
 			for (int i=1; i<(route.length); i++) 
        		{   
        		bananaclass.InitiateLocVars( i, cities[i].x, cities[i].y);	
        		}  



				
// Calculation Function				
				bananaclass.AlgorithmS1();


       	 		route[0] = new PointP(cities[0]);   // starting point should not change
        
        			for (int i=1; i<route.length; i++) 
        			{
            		route[i] =  new PointP(cities[bananaclass.FinalArray[i]]);
            		LocationsXDone[i-1] = bananaclass.LocationsX[bananaclass.FinalArray[i]];
            		LocationsYDone[i-1] = bananaclass.LocationsY[bananaclass.FinalArray[i]];
       		 		}
	
       			Answer = true;
        		return route;
    			}
    	
    	

    
    			public String getAuthors() 
    				{
        			return "Pieter Weterings & Nacor Martina";
   					 }
    
   
    			public String getDescription() 
    				{
        			return "Solves all yer Problems....";
    				}

    
}

 
 
 
 
 
 





 class BananaClass 
 	{
 	
//############################################################################
//						Declaration of Variables
//############################################################################


//----------------------------------------------------------------------------
// Public Variables
//----------------------------------------------------------------------------
	public int target_amount;
	public int RecurCounter = 0;  

//----------------------------------------------------------------------------
// Size Definitions for the Grid 
//----------------------------------------------------------------------------
	public int GridSizeX; // PizzaPanel.COLS
	public int GridSizeY; // PizzaPanel.ROWS


//----------------------------------------------------------------------------
// Public Array's & Vars Defined from other classes
//----------------------------------------------------------------------------
	
	public int [] LocationsX   	= 		new int[100];
	public int [] LocationsY   	= 		new int[100];	
	public int [] NotMultiDist 	= 		new int[100]; // Has the locations not added to the MultiDist array		
	public int [] FinalArray	= 		new int[100]; // serves as index for the MultiDist Array and as the export Array of the final points		
	public int [] MultiDist    	= 		new int[100]; // Has the pointer locations for graph 
	
	String[] ThaBigOne         	= 		new String [2000];    // holds all the data on the distance from lines to points


// amount of targets to be implemented
	void InitiateLocVars(int i,int Xloc,int Yloc)
 			{
 			LocationsX[i] = Xloc; 
 			LocationsY[i] = Yloc;		
 			}		 


//----------------------------------------------------------------------------
// Constructor
//----------------------------------------------------------------------------

	BananaClass() 
	{
 	}


	
//----------------------------------------------------------------------------
//############################################################################
//								Code				
//############################################################################
//----------------------------------------------------------------------------
  
void AlgorithmS1()
{



//----------------------------------------------------------------------------
// Local Varibles & Arrays
//----------------------------------------------------------------------------

int CountKeeper		= 0; 

int CornerXminYmax 	= 0;
int CornerXmaxYmax 	= 0;
int CornerXmaxYmin 	= 0;
int CornerXminYmin 	= 0;


int	[] CurrZeroDist 	= new int[target_amount+5];
int [] RecurPointer 	= new int[target_amount+5]; 
int [] youBetterThenMe 	= new int[target_amount+5];

		
		
		for (int o = 1; o<=(target_amount);o++)
			{

// calculation for CornerXminYmin
//----------------------------------------------------------------------------
				if((LocationsX[o] != 0)||(LocationsY[o] != 0))
					{
					
				if( ((LocationsX[o]+ LocationsY[o] ) < (LocationsX[CornerXminYmin]+ LocationsY[CornerXminYmin])) || (CornerXminYmin == 0)   )
							{
								CornerXminYmin = o;
							}
					
					else if((LocationsX[o]+ LocationsY[o]) == (LocationsX[CornerXminYmin]+ LocationsY[CornerXminYmin]))
							{
						
								if(LocationsY[o] < LocationsY[CornerXminYmin])
									{
								CornerXminYmin = o;	
									}
							
							}
					}


// calculation for CornerXmaxYmax
//----------------------------------------------------------------------------				
					if( ((LocationsX[o]+ LocationsY[o] ) > (LocationsX[CornerXmaxYmax]+ LocationsY[CornerXmaxYmax])) || (CornerXmaxYmax == 0)   )
							{
							CornerXmaxYmax = o;
							}
					
					else if((LocationsX[o]+ LocationsY[o]) == (LocationsX[CornerXmaxYmax]+ LocationsY[CornerXmaxYmax]))
							{
						
								if(LocationsX[o] > LocationsX[CornerXmaxYmax])
									{
										
									CornerXmaxYmax = o;	
									}
							
							}
				
				
// calculation for CornerXmaxYmin
//----------------------------------------------------------------------------				
				
				if(  (((Math.abs(GridSizeX-LocationsX[o])) + LocationsY[o]) < ((Math.abs(GridSizeX-LocationsX[CornerXmaxYmin])) + LocationsY[CornerXmaxYmin]))||(CornerXmaxYmin == 0))
						{
							CornerXmaxYmin = o;		
						}
					
			else if(((Math.abs(GridSizeX-LocationsX[o])) + LocationsY[o]) == ((Math.abs(GridSizeX-LocationsX[CornerXmaxYmin])) + LocationsY[CornerXmaxYmin]))
							{
						
								if(LocationsX[o] > LocationsX[CornerXmaxYmin])
									{
										
									CornerXmaxYmax = o;	
									}
							
							}
				

// calculation for CornerXminYmax
//----------------------------------------------------------------------------

					if(  (((Math.abs(GridSizeY-LocationsY[o])) + LocationsX[o]) < ((Math.abs(GridSizeY-LocationsY[CornerXminYmax])) + LocationsX[CornerXminYmax]))||(CornerXminYmax == 0))
						{
							CornerXminYmax = o;		
						}
					
			else if(((Math.abs(GridSizeY-LocationsY[o])) + LocationsX[o]) == ((Math.abs(GridSizeY-LocationsY[CornerXminYmax])) + LocationsX[CornerXminYmax]))
							{
						
								if(LocationsX[o] < LocationsX[CornerXmaxYmin])
									{
										
									CornerXminYmax = o;	
									}
							
							}
											
	}


// adding the corner locations to the Multidist Array
//----------------------------------------------------------------------------
MultiDist[1] = CornerXminYmax;
MultiDist[2] = CornerXmaxYmax;
MultiDist[3] = CornerXmaxYmin;
MultiDist[4] = CornerXminYmin;



// removing double values from the Array:
//----------------------------------------------------------------------------

for(int r = 1; r <= 3; r++)
	{
		for(int b = (r+1); b <= 4; b++)
		{	
			if((MultiDist[r]==MultiDist[b])&&(r!=b))
				{
					if (r == 1)
						{
							if (b == 2)
							{
								if((((GridSizeX-1)-LocationsX[MultiDist[r]])+ ((GridSizeY-1)-LocationsY[MultiDist[r]]))<((Math.abs((GridSizeY-1)-LocationsY[MultiDist[r]])) + LocationsX[MultiDist[r]]))
								{
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
							if (b == 3)
							{
								if(((Math.abs((GridSizeX-1)-LocationsX[MultiDist[r]])) + LocationsY[MultiDist[r]])<((Math.abs((GridSizeY-1)-LocationsY[MultiDist[r]])) + LocationsX[MultiDist[r]]))
								{
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
							if (b == 4)
							{
								if((LocationsX[MultiDist[r]]+ LocationsY[MultiDist[r]]) < ((Math.abs((GridSizeY-1)-LocationsY[MultiDist[r]])) + LocationsX[MultiDist[r]]))
								{
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
						}
					if (r == 2)
						{	
						if (b == 3)
							{
								if(((Math.abs((GridSizeX-1)-LocationsX[MultiDist[r]])) + LocationsY[MultiDist[r]]) < (((GridSizeX-1)-LocationsX[MultiDist[r]])+ ((GridSizeY-1)-LocationsY[MultiDist[r]])))
								{	
										
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
							if (b == 4)
							{
								if((LocationsX[MultiDist[b]]+ LocationsY[MultiDist[b]]) < (((GridSizeX-1)-LocationsX[MultiDist[r]])+ ((GridSizeY-1)-LocationsY[MultiDist[r]])))
								{
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
						}
					
					if (r == 3)
						{
							if (b == 4)
							{
								if( ((Math.abs((GridSizeX-1)-LocationsX[MultiDist[b]])) + LocationsY[MultiDist[b]]) < (LocationsX[MultiDist[r]]+ LocationsY[MultiDist[r]]))
								{
									MultiDist[r] = 0;	
								}
								else
								{
									MultiDist[b] = 0;
								}
							}
						}
	
				}
		}
	}





// checking for additional border points
//----------------------------------------------------------------------------

CornerXminYmax = MultiDist[1];
CornerXmaxYmax = MultiDist[2];
CornerXmaxYmin = MultiDist[3];
CornerXminYmin = MultiDist[4];

for (int o = 1; o<=(target_amount);o++)
			{
			
			//if ((LocationsY[o] < LocationsY[CornerXminYmax])&&(LocationsX[o] < LocationsX[CornerXminYmax])&&(LocationsY[o]!=0)
			//	{
			//	MultiAdder(0,o);	
			//	}	
			
			
			if((LocationsY[o] >= LocationsY[CornerXmaxYmax])&&(LocationsX[o] < LocationsX[CornerXmaxYmax])&&(LocationsX[CornerXminYmax] != LocationsX[o])) 
				{
				MultiAdder(1,o);		
				} 	
						
			if((LocationsX[o] >= LocationsX[CornerXmaxYmax])&&(LocationsY[o] < (LocationsY[CornerXmaxYmax]))&&(LocationsY[CornerXmaxYmin] != LocationsY[o])) 
				{
				MultiAdder(2,o);	
				}

			
			if((LocationsY[o] <= (LocationsY[CornerXmaxYmin]))&&(LocationsX[o] < LocationsX[CornerXmaxYmin])&&(LocationsX[CornerXminYmin] != LocationsX[o])) 
				{	
				MultiAdder(3,o);		
				}	
						

			}
			
// Multidist 0 Removal
//----------------------------------------------------------------------------			
for (int i = 1; i<=(target_amount+1);i++)
{
	if(MultiDist[i] == 0)
	{
		while((MultiDist[i] == 0)&&(CountKeeper<(target_amount+1)))
		{
		
				for(int f = i;f <= target_amount+1; f++  )
				{
				MultiDist[f] = MultiDist[f+1];
				MultiDist[f+1] = 0;	
				}
				CountKeeper++;
		}
	}
}

CountKeeper = 0;	

// checking which locations are not added to the MultiDist array	
//-----------------------------------------------------------------------------				

	for(int he = 1; he<=target_amount; he++)
		{
	
			boolean b_add = true;
	
			for(int v = 0; v <= target_amount; v++)
			{
				
				if (he == MultiDist[v])
				{
				b_add = false;	
				}
			}
	
			if (b_add == true)
			{
			CountKeeper++;
			NotMultiDist[CountKeeper] = he ;
			}
			
		}

	
//IMPORTANT!!!!!!!! Definitions of the starting Position of the Robot; not used further in the Solver
	LocationsX[0] = 0;
	LocationsY[0] = 0;
	



// Loop creates formulae between follow-up points in the Array "MultiDist" (Buffer Array for Final Array)
//-----------------------------------------------------------------------------	
	
	for( int i = 0; i <= (target_amount); i++)
		{


// Guide for formula creation between two defined points:
//+----------------------------------------------------------------------------------------------
//|
//| this statement creates a line formula to check the distance to the (several) remaining points
//| Y = a(X-c) + b		a = the multiplier;(y1-y2)/(x1-x2)
//| 					b = the distance from the starting point to the X-axis
//|						c = the distance from the starting point to the Y-axis
//|
//| NOTE: The coordinate with the smallest X is the start of the graph (otherwise creation was impossible)
//+-----------------------------------------------------------------------------------------------
			
			
			if(LocationsX[MultiDist[i]] < LocationsX[MultiDist[i+1]])
				{
				int c = LocationsX[MultiDist[i]];
				int b = LocationsY[MultiDist[i]];

				float a1 = (LocationsY[MultiDist[i]]-LocationsY[MultiDist[i+1]]);
				float a2 = (LocationsX[MultiDist[i]]-LocationsX[MultiDist[i+1]]);
				float a = a1 / a2;
				
				boolean isNinetyDegrees = false;
				System.out.println(" (<) The Formula between the coordinates " + MultiDist[i] + " and " + MultiDist[(i+1)] + " is: Y = " + a + "X + " + b);
				
				FinalAdd(LocationsX[MultiDist[i]],LocationsX[MultiDist[i+1]], a, b, c, i, isNinetyDegrees);
			
				}
	
			
			
			
			else if(LocationsX[MultiDist[i+1]] < LocationsX[MultiDist[i]])
				{
				int c = LocationsX[MultiDist[i+1]];
				int b = LocationsY[MultiDist[i+1]];
				
				float a1 = (LocationsY[MultiDist[i]]-LocationsY[MultiDist[i+1]]);
				float a2 = (LocationsX[MultiDist[i]]-LocationsX[MultiDist[i+1]]);
				float a = a1 / a2;
				
				boolean isNinetyDegrees = false;
				System.out.println(" (>) The Formula between the coordinates " + MultiDist[i] + " and " + MultiDist[(i+1)] + " is: Y = " + a + "X + " + b);
				
				 FinalAdd(LocationsX[MultiDist[i+1]],LocationsX[MultiDist[i]], a, b, c, i, isNinetyDegrees);
				}
			
			
			
			
			
			else if((LocationsX[MultiDist[i+1]] ==  LocationsX[MultiDist[i]])&&((MultiDist[i]!=0)||(MultiDist[i+1]!=0)))
				{
// Should the coordinate's x be the same for both locations; a graph creation would be impossible
					int c = 0 ;
					int b = 0 ;
					float a = 0 ;
					boolean isNinetyDegrees = true;
					
					System.out.println("equal X from " + MultiDist[i] + " and " + MultiDist[i+1]);
					
					if(LocationsY[MultiDist[i+1]] > LocationsY[MultiDist[i]])
						{
						FinalAdd(LocationsY[MultiDist[i]],LocationsY[MultiDist[i+1]], a, b, c, i, isNinetyDegrees);
						}
					else
						{
						FinalAdd(LocationsY[MultiDist[i+1]],LocationsY[MultiDist[i]], a, b, c, i, isNinetyDegrees);
						}
			
			

						
			
				
				
				}
			else
				{
// In case of an graph generation error:
			System.out.println("No Comply from " + MultiDist[i] + " and " + MultiDist[i+1]);
				}
		}
			
		
			
			
			
		 	
		 	for(int d = 0; d<= (target_amount+4); d++)
				{
				CurrZeroDist[d] = 0;
				}
							
							
								
// RecurPointer Points towards the starting location of the graph's data in the array
//-----------------------------------------------------------------------------		 
			RecurCounter = 0;
			
			for(int d = 0; d<= (ThaBigOne.length-1); d++)
				{
					if(ThaBigOne[d] == "<<STRT>>")
							{

							RecurPointer[RecurCounter] = (d + 1);
							RecurCounter++;
							}
				}
							





//Array Dissimulation (ThaBigOne )
//-----------------------------------------------------------------------------

for(int g = 0; g <FinalArray.length; g++)
	{
	FinalArray[g] = 0;	
	} 

						
// Guide for the Array Dissimulating loop:
//+-------------------------------------------------------------------------------------------+
//|
//|
//|
//| RecurPointer:             [A],                    		[B],
//|							   |                      		 |
//|	ThaBigOne:   	  <<STRT>>,A,B,C,D,E,C,D,E,C,D,E,<<STRT>>A,B,.........
//|
//| A = Strart of the graph to which the target distance is checked
//| B = Index for targets being checked (amount)
//| C = target being checked (the point you click on at the start of the program)
//| D = distance from the target to the graph; checked from (Xtarget-0,5) to (Xtarget+0,5)
//| E = distance to the starting point of the graph from the target
//+-------------------------------------------------------------------------------------------+
	
	
// (1) What Location in the NotMultiDist Array to check? value NotMultiDist[0] - NotMultiDist[NotMultiDist.length-1]	
	
	
	for(int NotMultiDistNr = 1; NotMultiDistNr <= CountKeeper; NotMultiDistNr++)
		{
						float ClosestTo = 0;
						int OrderByDistanceToLine = 0;
						int StartingPointInArray = 0;	
		
			
// (2) Indicates where to start in the Distance Array
			for( int DistIndx = 0; DistIndx < RecurCounter; DistIndx++)
					{
						
// (3) Indicates for how long to repeat checking for coords (uses B)
									;
						for( int repeatIndx = 0; repeatIndx <= Integer.parseInt(ThaBigOne[((RecurPointer[DistIndx])+1)]); repeatIndx++)
							{
		
// (3.1) Checks whether the requisted target is added to the array								
								if( (Integer.parseInt(ThaBigOne[(RecurPointer[DistIndx])+2 +(repeatIndx*3)])) == NotMultiDist[NotMultiDistNr])
									{

// (3.2) Changes the smallest value for the target to the current distance?												
												if( (Float.parseFloat(ThaBigOne[(RecurPointer[DistIndx])+(repeatIndx*3)+3])< ClosestTo)|| (ClosestTo == 0))
													{	

													ClosestTo = Float.parseFloat(ThaBigOne[(RecurPointer[DistIndx])+(repeatIndx*3)+ 3]);
													StartingPointInArray = Integer.parseInt(ThaBigOne[RecurPointer[DistIndx]]);
													OrderByDistanceToLine = Integer.parseInt(ThaBigOne[(RecurPointer[DistIndx])+(repeatIndx*3)+ 4]);
													}
													
// (3.2.1) In the unlikely event two distances may be the same..
									}
								
							}
							




// (4) at the end of the loop the target is placed on the right place of the Buffer Array							
//-----------------------------------------------------------------------------								


// Guide for using the CurrZeroDist Array:
//+-------------------------------------------------------------------
//|
//|						   <b>  
//|							|  
//|CurrZeroDist: ,  ,  ,  , a,  ,  ,..... 
//|							|  
//|FinalArray  :0,e1,e2,e3,  ,e4,e5, ....
//|
//|a = location nearest to the graph e3, placed at FinalArray[e3+1] when CurrZeroDist is complete
//|    (var StartingPointInArray+1 used for point in array)
//|b = Possibly, there are more locations closest to graph e3, they are sorted on distance towards
//|    the starting loc of the graph (point e3), and form thearray <b>
//|NOTE = the length of b should be added to any follow up point in the CurrZeroDist array to prevent
//|    problems (done by the FinalArray array)
//+-------------------------------------------------------------------

			if ((DistIndx == (RecurCounter-1))&&(NotMultiDist[NotMultiDistNr]!= 0))
						{


//----------------------------------------------------------------------------------------------------------
// !!!!!!!!!!!!!!!!!!WARNING: DO NOT MESS AROUND WITH!!!!!!!! VERY DELICATE AND DIFFICULT CODING!!!!!!!!!!!!!!!!
//----------------------------------------------------------------------------------------------------------



							
							
							for (int zak = (target_amount); zak > (StartingPointInArray + FinalArray[StartingPointInArray+1]); zak--)
													{
													CurrZeroDist[zak] = CurrZeroDist[zak-1];
													CurrZeroDist[zak-1] = 0;
													
													youBetterThenMe[zak] = youBetterThenMe[zak-1];
													youBetterThenMe[zak-1] = 0;
													}
	
							
									
							if (youBetterThenMe[(StartingPointInArray + FinalArray[StartingPointInArray+1])]== 0)
								{ 

										if (CurrZeroDist[((StartingPointInArray) + 2 + (FinalArray[StartingPointInArray+1]))] != 1024)
											{
												
												for( int checkIt = (StartingPointInArray + 2 + FinalArray[StartingPointInArray+1]); checkIt <=  ((StartingPointInArray) + 2 + (FinalArray[StartingPointInArray+1])) +(FinalArray[StartingPointInArray+2]-FinalArray[StartingPointInArray+1]); checkIt++)
													{
														
														
														if ((youBetterThenMe[checkIt] < OrderByDistanceToLine) && (youBetterThenMe[checkIt]!= 0))
																{
																CurrZeroDist[checkIt-1] = CurrZeroDist[checkIt];
																CurrZeroDist[checkIt] = 0;
													
																youBetterThenMe[checkIt-1] = youBetterThenMe[checkIt];
																youBetterThenMe[checkIt] = 0;
																}
														
														
													else if ((youBetterThenMe[checkIt] >= OrderByDistanceToLine) && (youBetterThenMe[checkIt]!= 0))
																{
																
																CurrZeroDist[checkIt-1] = NotMultiDist[NotMultiDistNr];
																youBetterThenMe[checkIt-1] = OrderByDistanceToLine;
																break;
																}
																
													else if (youBetterThenMe[checkIt] == 0)
																{
																
																CurrZeroDist[checkIt-1] = NotMultiDist[NotMultiDistNr];
																youBetterThenMe[checkIt-1] = OrderByDistanceToLine;
																break;
																}
															
															else 
																{
																	System.out.println( "Critical exception for coord" + NotMultiDist[NotMultiDistNr] + "at" + checkIt);
																}
															
															
													}
													
											System.out.println(" target " + NotMultiDist[NotMultiDistNr] + " is part of the " + MultiDist[StartingPointInArray] + " - "+MultiDist[StartingPointInArray+1] + " group with lenght " + (FinalArray[StartingPointInArray+2]-FinalArray[StartingPointInArray+1]));
											}
										
										
										
										else if(youBetterThenMe[((StartingPointInArray) + 2 + (FinalArray[StartingPointInArray+1]))]== 0)
											{
												CurrZeroDist[(StartingPointInArray+1 + FinalArray[StartingPointInArray+1])] = NotMultiDist[NotMultiDistNr];
												youBetterThenMe[(StartingPointInArray+1 + FinalArray[StartingPointInArray+1])] = OrderByDistanceToLine;
											}
								
								}	
								else 	
								{				
					
									
							    }

						for (int zak = (target_amount+1); zak > (StartingPointInArray+1); zak--)
								{
								FinalArray[zak] = FinalArray[zak] + 1;	
													
								}
					
						
						
						CurrZeroDist[0]= 0;
				
			
				
				}
							
							
			}
				

		}
		

//----------------------------------------------------------------------------------------------------------
//                            !!!!!!!!!!!!!!!!!!END OF HARD CODING STUFF!!!!!!!!!!!!!!!!
//----------------------------------------------------------------------------------------------------------

for(int g = 0; g <FinalArray.length; g++)
	{
	FinalArray[g] = 0;	
	} 



// inserting the spare targets
//-----------------------------------------------------------------------------
		System.out.print("MULTIDIST : ");
				for(int tero = 0; tero < (target_amount+1); tero++)
								{
							System.out.print(MultiDist[tero] + " ");
								}
				System.out.println("");
	
	
	
	
		System.out.print("BUFFER ARRAY: ");
				for(int tero = 0; tero < (target_amount+1); tero++)
								{
							System.out.print(CurrZeroDist[tero] + " ");
								}
				System.out.println("");
				
				
				System.out.print("VALUE BUFFER; ");
				for(int tero = 0; tero < (target_amount+1); tero++)
								{
								System.out.print( + youBetterThenMe[tero] + " ");	
								}
			System.out.println("");		
				System.out.println("=====================================================================");

//----------------------------------------------------------------------------
// optional trace to check the clicked coords
		for (int b = 1; b<= this.target_amount; b++) 
			{
			System.out.println( "Location " + (b) + ": " + LocationsX[b] + " " + LocationsY[b]);
			
			}
			
			
			
int torn = 0;

	
	for(int gaar = 0; gaar <= (target_amount+1); gaar++)
		{
			
			 	if (CurrZeroDist[gaar] == 0)
					{	
							
						FinalArray[gaar] = MultiDist[torn];
						torn++;

						//	System.out.println("No Value:  " );
							
						//	for(int tero = 0; tero < (target_amount+2); tero++)
						//		{
						//		System.out.print(FinalArray[tero] + " ");	
						//		}
						//		
						//	System.out.println("");
							
					}
			
				else if(CurrZeroDist[gaar]!= 0)
					{
						FinalArray[gaar] = CurrZeroDist[gaar];
					//		
					//		System.out.println("Value is there: " );
					//		for(int tero = 0; tero < (target_amount+3); tero++)
					//			{
					//			System.out.print(FinalArray[tero] + " ");	
					//			}
					//			
					//		System.out.println("");
							
							
					}
					
						
						
						
						
						
						
				}
							
		FinalArrange();	

}




//----------------------------------------------------------------------------------------------------------
/*лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
		ллллл		лллллл		лллллл		лллллл		лллллл		лллллл
	лл	  	лл		лл		лл		лл		лл		лл		лл		лл		лл

									"THE END"


	лл		лл		лл		лл		лл		лл		лл		лл		лл		лл
  лллллл	 лллллл      лллллл       лллллл      лллллл     лллллл       лллллл	
  лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
*/
//----------------------------------------------------------------------------------------------------------














//----------------------------------------------------------------------------------------------------------
// function to add points in the first generation MultiDist Array()
//----------------------------------------------------------------------------------------------------------


void MultiAdder(int PointinArray, int o)
{
	System.out.print("MULTIDIST   ");
					
					
					for(int r = 0; r < target_amount+5; r++)
						{
						System.out.print(MultiDist[r] + " ");
						}
					System.out.println("");	
				
				
				
					for(int i = 4; i > PointinArray; i--)
					{
					FinalArray[i] = FinalArray[i] + 1;		
					}
					
					
					
					
					for(int i = target_amount; i > (PointinArray+1+FinalArray[PointinArray]); i--)
					{
					MultiDist[i] = MultiDist[i-1];
					MultiDist[i-1] = 0;	
					}



// Case: Their are no coords added between these two points
//---------------------------------------------------------------------------------------------------					
	if((FinalArray[PointinArray+1] - FinalArray[PointinArray])==1)
	{
		
		System.out.println("CASE: Their are no coords added between these two points" + o);	
		MultiDist[PointinArray +1+ FinalArray[PointinArray]] = o;
	
	//------------------------------------------------				
						
					System.out.print("FinalArray ");
					for(int r = 0; r < 5; r++)
						{
						System.out.print(FinalArray[r] + " ");
						}
					System.out.println("");	
					
					System.out.print("MULTIDIST   ");
					for(int r = 0; r < target_amount + 5; r++)
						{
						System.out.print(MultiDist[r] + " ");
						}
					System.out.println("");	
					System.out.println("");	
				
				
	//------------------------------------------------			
	}
	
// Case: Their ARE coords added between these two points
//---------------------------------------------------------------------------------------------------						
	else if((FinalArray[PointinArray+1] - FinalArray[PointinArray])>1) 
	{
		System.out.println("CASE: Their ARE coords added between these two points" + o);
					
					boolean BreakYou = false;
					
					for(int i = (PointinArray + 2 + FinalArray[PointinArray]); i <= (PointinArray+1) + FinalArray[PointinArray] + ((FinalArray[PointinArray+1] - FinalArray[PointinArray])-1);i++)	
						{
					
					System.out.println("");	
					System.out.print("CHECKING POINT: " + MultiDist[i]);
					System.out.println("");	
							
					if (BreakYou == false)	
					{
					
					
// o = Nearer					
//-----------------------------------------------------------------------------						
						if ((((Math.abs(LocationsX[o]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[o]-LocationsY[MultiDist[PointinArray]])) )<((Math.abs(LocationsX[MultiDist[i]]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[MultiDist[i]]-LocationsY[MultiDist[PointinArray]])) ))&&(MultiDist[i]!=0))
							{
							MultiDist[i-1] = o;
							System.out.print(o + " is Nearer then " + MultiDist[i]);
							BreakYou = true;
								
							}
							
// o = Equal							
//-----------------------------------------------------------------------------								
						else if ((((Math.abs(LocationsX[o]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[o]-LocationsY[MultiDist[PointinArray]])) )==((Math.abs(LocationsX[MultiDist[i]]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[MultiDist[i]]-LocationsY[MultiDist[PointinArray]])) ))&&(MultiDist[i]!=0))
							{
								if(LocationsX[o]< LocationsX[MultiDist[i]] )
								{
								MultiDist[i-1] = o;
								
								System.out.print(o + " is equal to " + MultiDist[i]);
								BreakYou = true;	
								}
								
								else
								{
								MultiDist[i] = MultiDist[i-1];	
								}
								
								
								
								
							}
// o = Further							
//-----------------------------------------------------------------------------								
						else if ((((Math.abs(LocationsX[o]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[o]-LocationsY[MultiDist[PointinArray]])) )>((Math.abs(LocationsX[MultiDist[i]]-LocationsX[MultiDist[PointinArray]]))+(Math.abs(LocationsY[MultiDist[i]]-LocationsY[MultiDist[PointinArray]])) )))
							{
								if (MultiDist[i]!=0)
								{
								MultiDist[i-1] = MultiDist[i];
								MultiDist[i] = 0;	
								System.out.print(MultiDist[i-1] + " Has been moved");
								}
								
								if(i ==((PointinArray+1)+((FinalArray[PointinArray+1] - FinalArray[PointinArray])-1)))
									{
									MultiDist[i] = o;
									System.out.print(o + " is further " + MultiDist[i-1]);
									BreakYou = true;	
									}
							}
							
						
						}
						
						}
						
					
					
				//------------------------------------------------				
						System.out.println(" ");
					System.out.print("FinalArray");
					for(int r = 0; r < 5; r++)
						{
						System.out.print(FinalArray[r] + " ");
						}
					System.out.println("");	
					
					System.out.print("MULTIDIST");
					for(int r = 0; r < target_amount + 5; r++)
						{
						System.out.print(MultiDist[r] + " ");
						}
					System.out.println("");	
					
				
				System.out.println("LeftTop - RightTop: " + o);	
				//------------------------------------------------		
			}	
				
}










//----------------------------------------------------------------------------------------------------------
// function to add the final wayward points (called by function AlgorithmS2)
//----------------------------------------------------------------------------------------------------------

void FinalAdd(int XlocMin,int XlocMax,float a,int b,int t, int route, boolean IsNinetyDegrees)
{
	int valuetrue = 0;
	int houdbij = 0;
	



	for(int c = 0; c <= target_amount; c++)
	{
					if(IsNinetyDegrees==false)
					{
							if( ( XlocMin <= LocationsX[NotMultiDist[c]]) && (LocationsX[NotMultiDist[c]] <= XlocMax) && (NotMultiDist[c] != 0))
							{
							valuetrue++;
							float gek;
				
// Syntax for the Distance array:
//+--------------------------------------------------------------------------------------------------------
//|		1) Distance[a] 	=  		segment starts of with the <<STRT>> command, this devides the outcomes for different graphs
//|		2) Distance[a+1]=  		contains the calling graph (<ted> variable in the AlgorithmS2 function)
//|		3) Distance[a+2]=		contains the index for the graph		
//|		3) Distance[(a+3)*b]= 	Value of the coord being checked, b indicates index place
//|		4) Distance[(a+4)*b]=	Distance from the graph to the coord
//| 	5) Distance[(a+5)*b]=	Distance from the starting point of the graph to the target
//+------------------------------------------------------------------------------------------	



// checks whether it has to make a new devision in the Distance[] array 
							if (valuetrue == 1)
								{
								ThaBigOne[RecurCounter] = "<<STRT>>";
								RecurCounter++;
								ThaBigOne[RecurCounter] = Integer.toString(route);
								RecurCounter++;
								houdbij = RecurCounter;
								RecurCounter++;
			
								}
				
				
// checks the actual distance to the graph that called the function (uses base X of the point)				
				 				
				 				float gek1 =  (LocationsY[NotMultiDist[c]]);
				 				float gek2 = (LocationsX[NotMultiDist[c]]- t);
				 				float gek3 = b;
				 		
				 				
				 				gek =Math.abs( gek1 - ((a * gek2) + gek3) );




// checks whether the graph is nearer +0.5X and -0.5X; reduces the chance for simular values	
				 			
				 					
				 				 gek2 = LocationsX[NotMultiDist[c]]- t + ((float) 0.5);

				 			
				 				if ( (Math.abs( gek1 - ((a * gek2) + gek3)) < gek) && (( XlocMin <= (LocationsX[NotMultiDist[c]]+0.5)) && ((LocationsX[NotMultiDist[c]]+0.5) <= XlocMax))  )
									{
									gek =Math.abs( gek1 - ((a * gek2) + gek3));
									}
							

				 				 gek2 = LocationsX[NotMultiDist[c]]- t - ((float) 0.5);

						
				 				if ( (Math.abs( gek1 - ((a * gek2) + gek3)) < gek) && (( XlocMin <= (LocationsX[NotMultiDist[c]]-0.5)) && ((LocationsX[NotMultiDist[c]]-0.5) <= XlocMax))  )
									{
									gek =Math.abs( gek1 - ((a * gek2) + gek3));
									}
				
				
				
								ThaBigOne[RecurCounter] = Integer.toString(NotMultiDist[c]);
								RecurCounter++;
								ThaBigOne[RecurCounter]= Float.toString(gek);
								RecurCounter++;
								ThaBigOne[RecurCounter]=  Integer.toString( (Math.abs(Math.abs(LocationsX[NotMultiDist[c]])-Math.abs(LocationsX[MultiDist[route]]))) + (Math.abs(Math.abs(LocationsY[NotMultiDist[c]])-Math.abs(LocationsY[MultiDist[route]]))  ) );
								RecurCounter++;



				System.out.println("The Distance from " + NotMultiDist[c] + " to this Formula is: " + gek);


				
				
							}
		
					}
					
					
					
// In case of a vertical line (i.e. no graph would be possible
			else if(IsNinetyDegrees==true)
					{
					if( ( XlocMin <= LocationsY[NotMultiDist[c]]) && (LocationsY[NotMultiDist[c]] <= XlocMax) && (NotMultiDist[c] != 0)&&((LocationsX[MultiDist[t]]!=0)||(LocationsY[MultiDist[t]]!=0)||(LocationsY[MultiDist[t+1]]!=0)||(LocationsX[MultiDist[t+1]]!=0)))
							{
							
							
							valuetrue++;
							float gek;
							
							System.out.println(LocationsX[MultiDist[t]] +  " - " + LocationsX[NotMultiDist[c]] );
							
							System.out.println(NotMultiDist[c] + "got trough");
							
										if (valuetrue == 1)
											{
											ThaBigOne[RecurCounter] = "<<STRT>>";
											RecurCounter++;
											ThaBigOne[RecurCounter] = Integer.toString(route);
											RecurCounter++;
											houdbij = RecurCounter;
											RecurCounter++;
											}
							
								if((LocationsX[NotMultiDist[c]] == LocationsX[MultiDist[t]]))
									{
										gek =(float) 0.01;	
									}
								else
									{
										gek =(float)(Math.abs(LocationsX[NotMultiDist[c]]-LocationsX[MultiDist[t]]));  
									}
							
								
							
								
							ThaBigOne[RecurCounter] = Integer.toString(NotMultiDist[c]);
							RecurCounter++;
							ThaBigOne[RecurCounter]= Float.toString(gek);
							RecurCounter++;
							ThaBigOne[RecurCounter]=  Integer.toString( (Math.abs(Math.abs(LocationsX[NotMultiDist[c]])-Math.abs(LocationsX[MultiDist[route]]))) + (Math.abs(Math.abs(LocationsY[NotMultiDist[c]])-Math.abs(LocationsY[MultiDist[route]]))  ) );
							RecurCounter++;
							
							}
					}

//creating an index for this section of the array			
			if ((c == target_amount) && (valuetrue>0))
					{
					ThaBigOne[houdbij] = Integer.toString(valuetrue-1); 
					
				//		System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");		
							for(int tero = 0; tero <= RecurCounter-1; tero++)
								{
				//	System.out.println("Pre-use Calculation Array: "+ 	ThaBigOne[tero] );
								}
								
					}	
	
	
	
		}
	

 }
 
//--------------------------------------------------------------------------------------------------------------------
// function to remove crossing of previous locations & Erronous route repair (Even so, errors probably still remain)
//--------------------------------------------------------------------------------------------------------------------
 
 void FinalArrange()
	{
	
	float BaseDistance = 0;
	int Replacer;
	float DistanceChecker = 0;
	
		for(int g = 0; g < (target_amount+1);g++)
		{
   		BaseDistance = BaseDistance + ( (float) (Math.sqrt(((Math.abs(LocationsY[FinalArray[g]]-LocationsY[FinalArray[g+1]]))*(Math.abs(LocationsY[FinalArray[g]]-LocationsY[FinalArray[g+1]]))) + ((Math.abs(LocationsX[FinalArray[g]]-LocationsX[FinalArray[g+1]]))*(Math.abs(LocationsX[FinalArray[g]]-LocationsX[FinalArray[g+1]]))))  ));
		}
	
	
	System.out.println("***************** After Calculation Error Repair *******************");	
	System.out.println("Crossed Distance: " + BaseDistance);
	


// in case of Erronous starting Point 
//-----------------------------------------------------------------------------		
		for(int g = target_amount+3; g >= 1;g--)
			{
			FinalArray[g] = FinalArray[g-1];			
			}
		
		 	FinalArray[1] =  FinalArray[target_amount+1];
		 	FinalArray[target_amount+1] = 0;
		 
		 	DistanceChecker = 0;
		
			for(int g = 0; g < (target_amount+1);g++)
				{
   				DistanceChecker = DistanceChecker + ( (float) (Math.sqrt(((Math.abs(LocationsY[FinalArray[g]]-LocationsY[FinalArray[g+1]]))*(Math.abs(LocationsY[FinalArray[g]]-LocationsY[FinalArray[g+1]]))) + ((Math.abs(LocationsX[FinalArray[g]]-LocationsX[FinalArray[g+1]]))*(Math.abs(LocationsX[FinalArray[g]]-LocationsX[FinalArray[g+1]]))))  ));
				}
		
		System.out.println("DistanceChecker: " + DistanceChecker);
		
					if(DistanceChecker >= BaseDistance)	
						{
								System.out.println( "Restoring to base output (DistanceChecker >= BaseDistance)....");
								System.out.println("");
								
		 						FinalArray[target_amount+1] = FinalArray[1];	
					
							for(int h = 1; h < target_amount+2;h++)
								{
								FinalArray[h] = FinalArray[h+1];
								System.out.println(h + " restored - " + FinalArray[h]);			
								}
						
						}
					else
						{
						BaseDistance = DistanceChecker;
						System.out.println("checked "+ (target_amount+1)  + "(" +  LocationsX[FinalArray[1]] + " " + LocationsY[FinalArray[1]] + ") and 1 (" +  LocationsX[FinalArray[2]] + " " + LocationsY[FinalArray[2]] + ") NEW Crossed Distance: " + DistanceChecker);
						}
				
		 
		 		System.out.print("Export Array : ");
				for(int g = 0; g < (target_amount+2); g++)
								{
							System.out.print(FinalArray[g] + " ");
								}
				System.out.println("");
		 	
// in case of crossing lines
//-----------------------------------------------------------------------------		
	
for(int i = 0; i <2; i++)
	{	
	for(int g = 2; g < (target_amount+3);g++)
		{
		 
		 DistanceChecker = 0;
		 Replacer =	FinalArray[g];
		 FinalArray[g] =  FinalArray[g+1];
		 FinalArray[g+1] = Replacer	;
			
		
			for(int h = 0; h < (target_amount+3);h++)
				{
   				DistanceChecker = DistanceChecker + ( (float) (Math.sqrt(((Math.abs(LocationsY[FinalArray[h]]-LocationsY[FinalArray[h+1]]))*(Math.abs(LocationsY[FinalArray[h]]-LocationsY[FinalArray[h+1]]))) + ((Math.abs(LocationsX[FinalArray[h]]-LocationsX[FinalArray[h+1]]))*(Math.abs(LocationsX[FinalArray[h]]-LocationsX[FinalArray[h+1]]))))  ));
				}
				
				System.out.println("BaseDistance: " + BaseDistance );
					if(DistanceChecker >= BaseDistance)	
						{
								
						Replacer =	FinalArray[g];
		 				FinalArray[g] =  FinalArray[g+1];
		 				FinalArray[g+1] = Replacer;	
		 				
		 				System.out.println(DistanceChecker);
						System.out.println("checked "+ g + "(" +  LocationsX[FinalArray[g]] + " " + LocationsY[FinalArray[g]] + ") and " + (g+1) + "(" +  LocationsX[FinalArray[g+1]] + " " + LocationsY[FinalArray[g+1]] + ") ;No Improvement");
					
						}
					else
						{
							BaseDistance = DistanceChecker;
						System.out.println("checked "+ g + "(" +  LocationsX[FinalArray[g]] + " " + LocationsY[FinalArray[g]] + ") and " + (g+1) + "(" +  LocationsX[FinalArray[g+1]] + " " + LocationsY[FinalArray[g+1]] + ") NEW Crossed Distance: " + DistanceChecker);
						System.out.println(Replacer);
						
						System.out.println(FinalArray[g]);
						System.out.println(FinalArray[g+1])	;
						}
	
		}
		
		
		for(int h = 0; h < (target_amount+3);h++)
				{
   				if ((FinalArray[h] == 0)&&(h!=0))
					{
						System.out.println("0 found at:" + h );
					
						for(int j = h; j < (target_amount+5);j++)
							{
								
								FinalArray[j] = FinalArray[j+1];
								FinalArray[j+1] = 0;	
							}
				
					}
				}
		System.out.println("target_amount: " + target_amount);
		
		System.out.print("Export Array : ");
				for(int g = 0; g < (target_amount+5); g++)
								{
							System.out.print(FinalArray[g] + " ");
								}
				System.out.println("");
		

 		}
 
 	}
 
}